<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Attendance and Expense Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        /* --- Start of CSS --- */
        :root {
            --background-color: #f4f4f4;
            --text-color: #333;
            --container-bg-color: #fff;
            --border-color: #ddd;
            --input-bg: #fff;
            --input-text: #333;
            --input-placeholder: #bbb;
            --table-bg: #fff;
            --table-header-bg: #ddd;

            /* Button Variables (Light Mode Defaults) */
            --default-button-bg: transparent;
            --default-button-text: #333;
            --default-button-border: #ccc;
            --default-button-hover-bg: #e9e9e9;
            --default-button-hover-border: #adadad;

            --primary-color: #007bff;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --reminder-bg: #ffc107;
            --reminder-text: #343a40;
            --current-day-bg: #e0e0e0;
            --icon-placeholder-color: #bbb; /* Light mode default */
             --link-color: #0056b3; /* Added for hover effect */
        }

        html.dark {
            --background-color: #1a202c;
            --text-color: #a0aec0; /* Slightly lighter text for dark background */
            --container-bg-color: #2d3748; /* Darker background for main containers */
            --border-color: #4a5568;
            --input-bg: #2d3748;
            --input-text: #a0aec0;
            --input-placeholder: #718096;
            --table-bg: #2d3748;
            --table-header-bg: #4a5568;

            /* Button Variables (Dark Mode) */
             --default-button-bg: transparent; /* Keep transparent or use rgba(74, 85, 104, 0.2) */
             --default-button-text: #a0aec0; /* Light text color for dark mode buttons */
             --default-button-border: #4a5568; /* Darker border color */
             --default-button-hover-bg: rgba(74, 85, 104, 0.4); /* A darker hover background */
             --default-button-hover-border: #a0aec0; /* Border color on hover */


             --primary-color-dark: #63b3ed; /* Lighter blue for dark mode */
             --danger-color-dark: #fc8181; /* Lighter red */
             --warning-color-dark: #f6e05e; /* Lighter yellow */
             --reminder-bg: #f6ad55; /* Darker yellow for reminder */
             --reminder-text: #2d3748; /* Dark text on reminder */
            --current-day-bg: #4a5568;
            --icon-placeholder-color-dark: #718096; /* Dark mode placeholder */
             --link-color: #90cdf4; /* Added for hover effect */
        }

        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease; /* Smooth transition */
        }

        .container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 5px;
            padding: 10px; /* Added padding */
            background-color: var(--container-bg-color); /* Use variable */
            border: 1px solid var(--border-color); /* Use variable */
            border-radius: 5px; /* Added border radius */
        }

        input, select { /* Added select */
            padding: 6px;
            margin: 5px 0; /* Keep default margin unless overridden by a parent flex container */
            font-size: 14px;
            border: 1px solid var(--border-color); /* Use variable */
            background-color: var(--input-bg); /* Use variable */
            color: var(--input-text); /* Use variable */
            box-sizing: border-box;
            transition: border-color 0.2s ease, background-color 0.2s ease, color 0.2s ease;
        }
         select { cursor: pointer; }

        td input {
             border: none; background: none; padding: 0; margin: 0;
             text-align: center; display: block; width: 100%; height: 100%;
             box-sizing: border-box; color: inherit;
         }

         input::placeholder, td input::placeholder { color: var(--input-placeholder); opacity: 1; }

         td.rent-cell input[data-field="rent"],
         td.food-cell input[data-field="food"],
         td.received-cell input[data-field="received"] {
            padding-left: 0; text-align: center;
         }

        button {
            cursor: pointer;
            /* Use variables for default button styles */
            background-color: var(--default-button-bg);
            color: var(--default-button-text);
            border: 1px solid var(--default-button-border);

            border-radius: 4px; padding: 6px 10px;
            margin: 5px; font-size: 16px; min-width: 35px; text-align: center;
            display: inline-block; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
        }
        button:hover {
            /* Use variables for hover styles */
            background-color: var(--default-button-hover-bg);
            border-color: var(--default-button-hover-border);
            color: var(--default-button-text); /* Keep text color same as default state */
        }
        button:disabled { color: #aaa; border-color: #ddd; background-color: transparent; cursor: not-allowed; }
        /* Dark mode specific disabled styles (can keep hardcoded or use dark mode variables) */
        html.dark button:disabled { color:#5a6578; border-color:#404a59; background-color:transparent; }
        html.dark button:disabled:hover { background-color:transparent; }


         #addUserBtn {
             width: 35px; font-size: 18px; padding: 6px;
             border-color: #4CAF50; color: #4CAF50;
             margin: 5px; /* Ensure margin is consistent */
         }
         #addUserBtn:hover { background-color: #4CAF50; color: white; border-color: #4CAF50; }

        html.dark #addUserBtn { border-color:#48bb78; color:#48bb78; }
        html.dark #addUserBtn:hover { background-color:#48bb78; color: var(--background-color); }


        .table-responsive { overflow-x: auto; -webkit-overflow-scrolling: touch; margin-bottom: 10px; } /* Added margin */
        table { width: 100%; border-collapse: collapse; background: var(--table-bg); table-layout: fixed; border: 1px solid var(--border-color); /* Added border */ }
         th, td {
            border: 1px solid var(--border-color); padding: 4px; text-align: center;
            word-wrap: break-word; vertical-align: top; position: relative;
         }
         th {
             background-color: var(--table-header-bg); font-weight: bold;
             border-bottom: 1px solid var(--border-color);
             padding: 4px; /* Adjusted padding for better top border visibility */
             line-height: 1.2; /* Adjusted line-height */
             color: var(--text-color);
        }

        th:nth-child(1), td:nth-child(1) { width: 90px; } /* Date */
        th:nth-child(2), td:nth-child(2) { width: 25px; } /* Status */
        th:nth-child(3), td:nth-child(3) { width: 25px; } /* Overtime */
        th:nth-child(4), td:nth-child(4) { width: 25px; } /* Rent */
        th:nth-child(5), td:nth-child(5) { width: 25px; } /* Food */
        th:nth-child(6), td:nth-child(6) { width: 25px; } /* Received */
        th:nth-child(7), td:nth-child(7) { width: auto; min-width: 80px; } /* Notes */
        th:nth-child(8), td:nth-child(8) { width: 90px; } /* Edited */

        .rent-cell:not(.input-has-value)::before,
        .food-cell:not(.input-has-value)::before,
        .received-cell:not(.input-has-value)::before {
            font-family: "Font Awesome 5 Free"; font-weight: 900; position: absolute;
            left: 50%; top: 50%; transform: translate(-50%, -50%);
            color: var(--icon-placeholder-color); opacity: 0.7; font-size: 10px; z-index: 1;
            content: var(--icon-content, ""); /* Use CSS variable for content */
        }
         /* Define icon content using data attributes or CSS variables */
        .rent-cell::before { --icon-content: "\f015"; } /* Home icon */
        .food-cell::before { --icon-content: "\f2e7"; } /* Utensils icon */
        .received-cell::before { --icon-content: "\f53a"; } /* Hand-holding-dollar icon */

        html.dark .rent-cell:not(.input-has-value)::before,
        html.dark .food-cell:not(.input-has-value)::before,
        html.dark .received-cell:not(.input-has-value)::before {
             color: var(--icon-placeholder-color-dark);
        }

        .input-has-value::before { display: none !important; }

         #userTabs {
             margin-top: 10px; margin-bottom: 20px; padding: 10px;
             background-color: var(--container-bg-color); /* Use variable */
             border: 1px solid var(--border-color); /* Use variable */
             border-radius: 5px; display: flex; flex-wrap: wrap; gap: 5px;
             /* Initially hidden if no users exist, made flex by JS */
             display: none;
         }
         #userTabs button.user-tab-button {
             margin: 0; background-color: #f0f0f0; border: 1px solid #ccc; color: #333;
             padding: 4px 8px; /* Adjusted padding */
         }
         #userTabs button.user-tab-button:hover { background-color: #dcdcdc; border-color: #bbb; }
         #userTabs button.user-tab-button.active-user-tab {
             background-color: transparent; border: 1px solid var(--primary-color);
             color: var(--primary-color); font-weight: bold;
         }
         #userTabs button.user-tab-button.active-user-tab:hover {
              background-color: rgba(0, 123, 255, 0.1); border-color: #0056b3; color: #0056b3;
         }
         #userTabs button.user-tab-button.archived {
              background-color: transparent; border: 1px dashed #aaa; color: #777;
         }
          #userTabs button.user-tab-button.archived:hover {
              background-color: #f0f0f0; border-color: #888; color: #555;
          }

        /* Dark Mode Tabs */
        html.dark #userTabs button.user-tab-button {
             background-color: rgba(74, 85, 104, 0.5); /* Slightly different from main dark container */
             border-color: var(--default-button-border); /* Use the dark mode button border variable */
             color: var(--default-button-text); /* Use the dark mode button text variable */
        }
        html.dark #userTabs button.user-tab-button:hover {
             background-color: var(--default-button-hover-bg); /* Use dark mode hover background variable */
             border-color: var(--default-button-hover-border); /* Use dark mode hover border variable */
             color: var(--default-button-text); /* Keep dark mode text color */
        }
        html.dark #userTabs button.user-tab-button.active-user-tab {
            background-color: transparent; border-color:var(--primary-color-dark); color:var(--primary-color-dark);
        }
        html.dark #userTabs button.user-tab-button.active-user-tab:hover { background-color:rgba(100,181,246,0.15); }
        html.dark #userTabs button.user-tab-button.archived { border-style:dashed; border-color:#718096; color:#a0aec0; }
        html.dark #userTabs button.user-tab-button.archived:hover { background-color:var(--default-button-hover-bg); /* Use dark mode hover background variable */ }


         #userControl {
             margin-top: 20px; padding: 10px;
             background-color: var(--container-bg-color); /* Use variable */
             border: 1px solid var(--border-color); /* Use variable */
             border-radius: 5px;
             /* Initially hidden, made block by JS */
             display: none;
         }
          /* Direct children divs of userControl for layout */
          #userControl > div { /* Apply gap and flex wrap to direct children */
              display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
          }
           /* Specific layout for user name heading - it's the first direct div child */
          #userControl > div:first-child {
              justify-content: space-between; /* Keep username left, (old archive btn was right) */
          }
           /* Remove bottom margin from the last direct div child */
          #userControl > div:last-child {
              margin-bottom: 0;
          }

           /* New container for quick controls */
          #userQuickControls {
              display: flex; /* Arrange children (the 4 control divs) in a row */
              flex-wrap: wrap; /* Allow wrapping on smaller screens */
              gap: 10px; /* Space between these control groups */
              align-items: center;
              width: 100%; /* Take full width */
              margin-bottom: 15px; /* Add some space below this row */
          }
          /* Style for the individual control containers inside userQuickControls */
           #userQuickControls > div {
               display: flex; /* Keep internal flex for label+input/select */
               align-items: center;
               gap: 5px; /* Gap between (hidden) label and input/select */
               margin-bottom: 0; /* Remove default bottom margin when in flex row */
               flex-grow: 1; /* Allow items to grow and fill space */
               flex-basis: 150px; /* Suggest a starting width, allows shrinking */
               min-width: 120px; /* Ensure they don't get too small */
           }
           /* Hide labels within the quick controls */
           #userQuickControls label {
               display: none;
           }
           /* Ensure inputs and selects inside quick controls take space */
           #userQuickControls input,
           #userQuickControls select {
               flex-grow: 1;
               min-width: 0; /* Allow shrinking */
               margin: 0; /* Remove margin */
               /* Remove specific width styles from HTML */
           }


          #rateContainer, #overtimeRateContainer, #manualBalanceContainer, #includeBalanceContainer { /* Added #overtimeRateContainer */
               /* display: flex; align-items: center; gap: 10px; flex-wrap: wrap; margin-bottom:10px; */ /* These are now handled by #userQuickControls > div */
          }
           #userControl button { margin: 0; } /* Remove margin from buttons inside userControl */

          /* UPDATED Month Navigation Layout */
          #monthNavWrapper { width: 100%; margin-bottom: 10px; }
          #monthNav {
             display: flex; justify-content: space-between; align-items: center; width: 100%;
          }
          #monthNav .month-display-group { display: flex; align-items: center; gap: 5px; }
          #monthNav button { padding: 4px 8px; font-size: 14px; margin: 0; } /* Ensure no margin */
          #currentMonthDisplay { font-size: 1.1em; font-weight: bold; min-width: 100px; text-align: center; }

          /* UPDATED View Report Buttons Layout */
          #viewReportButtonsWrapper {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; margin-top: 15px; margin-bottom: 10px; gap: 5px; /* Added gap */
          }
          #viewReportButtonsWrapper button { flex-grow: 1; margin: 0;} /* Make buttons take equal space, remove margin */

          /* UPDATED Share Button Layout */
          #shareReportButtonWrapper {
            display: flex; justify-content: flex-end; width: 100%; margin-top: 10px;
             margin-bottom: 0; /* Ensure no bottom margin if it's the last div */
          }
          #shareReportButtonWrapper button { margin: 0; } /* Remove margin from share button */


         #summarySection {
             margin-top: 10px; padding: 10px;
             background-color: var(--container-bg-color); border: 1px solid var(--border-color);
             border-radius: 5px; margin-bottom: 10px; /* Added margin */
         }
         #summarySection h3 { margin-top: 0; }
         #summarySection hr { border-color: var(--border-color); margin: 0.5rem 0; }
         #summarySection p { margin: 0.2em 0; }


         #reportArea { /* Main wrapper for table, payments, summary, footer */
             /* No specific styles needed here unless acting as a flex/grid container */
             margin-top: 10px;
         }

         #reportFooter {
             margin-top: 10px; padding: 10px;
             background-color: var(--container-bg-color); border: 1px solid var(--border-color);
             border-radius: 5px; white-space: pre-wrap; font-size: 0.9em;
         }

         #dataManagementButtons {
             margin-top: 10px; padding: 10px;
             background-color: var(--container-bg-color); border: 1px solid var(--border-color);
             border-radius: 5px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center;
             /* Initially hidden, made flex/block by JS */
             display: none;
         }
         #dataManagementButtons button { margin: 0; padding: 6px 12px; font-size: 0.9em; }
         #dataManagementButtons button i { margin-right: 5px; }
         /* Styles for Archive/Reactivate button when moved */
        #archiveUserBtn.archive-style { border-color: #dc3545; color: #dc3545; }
        #archiveUserBtn.archive-style:hover { background-color: #dc3545; color: white; }
        #archiveUserBtn.reactivate-style { border-color: #ffc107; color: #b7791f; }
        #archiveUserBtn.reactivate-style:hover { background-color: #ffc107; color: #212529; }

        html.dark #archiveUserBtn.archive-style { border-color:var(--danger-color-dark); color:var(--danger-color-dark); }
        html.dark #archiveUserBtn.archive-style:hover { background-color:var(--danger-color-dark); color:var(--background-color); }
        html.dark #archiveUserBtn.reactivate-style { border-color:var(--warning-color-dark); color:var(--warning-color-dark); }
        html.dark #archiveUserBtn.reactivate-style:hover { background-color:var(--warning-color-dark); color:var(--reminder-text); }


        /* Modal styles */
        .modal { display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); }
        .modal-content { background-color: var(--container-bg-color); margin: 15% auto; padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; width: 80%; max-width: 500px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px; }
        .modal-title { margin: 0; font-size: 1.2em; font-weight: bold; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; }
        .close-button:hover, .close-button:focus { color: #000; text-decoration: none; cursor: pointer; }
        html.dark .close-button:hover, html.dark .close-button:focus { color: #fff; }

        .modal-body { margin-bottom: 10px; }
        .modal-footer { border-top: 1px solid var(--border-color); padding-top: 10px; margin-top: 10px; text-align: right; display: flex; justify-content: flex-end; gap: 10px; }
        .modal-footer button { padding: 8px 15px; margin: 0; } /* Remove margin */

        .modal-footer button[onclick*="closeImportModal"] { border-color: #6c757d; color: #6c757d; }
        .modal-footer button[onclick*="closeImportModal"]:hover { background-color: #6c757d; color: white; }
        .modal-footer button[onclick*="confirmImport('merge')"] { border-color: var(--primary-color); color: var(--primary-color); }
        .modal-footer button[onclick*="confirmImport('merge')"]:hover { background-color: var(--primary-color); color: white; }
        .modal-footer button[onclick*="confirmImport('replace')"] { border-color: var(--danger-color); color: var(--danger-color); }
        .modal-footer button[onclick*="confirmImport('replace')"]:hover { background-color: var(--danger-color); color: white; }

        /* Dark Mode Modal Footer Buttons */
        html.dark .modal-footer button[onclick*="closeImportModal"] { border-color:#90a4ae; color:#90a4ae;}
        html.dark .modal-footer button[onclick*="closeImportModal"]:hover { background-color:#90a4ae; color:var(--background-color); }
        html.dark .modal-footer button[onclick*="confirmImport('merge')"] { border-color:var(--primary-color-dark); color:var(--primary-color-dark); }
        html.dark .modal-footer button[onclick*="confirmImport('merge')"]:hover { background-color:var(--primary-color-dark); color:var(--background-color); }
        html.dark .modal-footer button[onclick*="confirmImport('replace')"] { border-color:var(--danger-color-dark); color:var(--danger-color-dark); }
        html.dark .modal-footer button[onclick*="confirmImport('replace')"]:hover { background-color:var(--danger-color-dark); color:var(--background-color); }


        .preview-section { border-bottom: 1px dashed var(--border-color); padding-bottom: 10px; margin-bottom: 10px; }
        .preview-header { font-weight: bold; margin-bottom: 5px; }
        .user-preview { border: 1px solid var(--border-color); padding: 10px; border-radius: 4px; background-color: var(--input-bg); margin-top: 10px; }
        .user-preview p { margin: 0.3em 0; font-size: 0.9em; }
        .import-option { margin-top: 15px; }
        .import-option ul { list-style: disc inside; margin: 0; padding-left: 20px; }
        .import-option li { margin-bottom: 5px; }

        #previousBalancePaymentsSection {
             margin-top: 10px; padding: 10px;
             background-color: var(--container-bg-color); border: 1px solid var(--border-color);
             border-radius: 5px; margin-bottom: 10px;
             /* Initially hidden, made block by JS */
             display: none;
         }
         #previousBalancePaymentsSection h3 { margin-top: 0; font-size: 1.1em; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
         #previousBalancePaymentsSection .payment-entry { display: flex; justify-content: space-between; align-items: center; padding: 5px 0; border-bottom: 1px dashed #eee; }
         html.dark #previousBalancePaymentsSection .payment-entry { border-bottom-color: rgba(255,255,255,0.1); }

         #previousBalancePaymentsSection .payment-entry:last-child { border-bottom: none; }
         #previousBalancePaymentsSection .payment-details { flex-grow: 1; margin-right: 10px; font-size: 0.9em; }

         .delete-payment-btn {
             background-color: transparent; color: #dc3545; border: 1px solid #dc3545;
             border-radius: 3px; padding: 1px 4px; font-size: 0.8em; cursor: pointer;
             margin-left: 10px; flex-shrink: 0; margin: 0; /* Remove margin */
         }
         .delete-payment-btn:hover { background-color: #dc3545; color: white; }
         html.dark .delete-payment-btn { border-color:var(--danger-color-dark); color:var(--danger-color-dark); }
         html.dark .delete-payment-btn:hover { background-color:var(--danger-color-dark); color:var(--background-color); }

         #addPaymentForm {
             margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);
             display: flex; flex-wrap: wrap; gap: 10px; align-items: center;
         }
         #addPaymentForm label { font-size: 0.9em; }
         #addPaymentForm input[type="number"], #addPaymentForm input[type="date"], #addPaymentForm input[type="text"] {
             flex-grow: 1; min-width: 100px; margin: 0; /* Adjusted margin */
        }
          @media (min-width: 640px) { /* Add button takes full width on small screens */
              #addPaymentForm input[type="number"], #addPaymentForm input[type="date"], #addPaymentForm input[type="text"] {
                  flex-grow: 0; /* Prevent growing on larger screens */
                  width: auto; /* Allow width based on content/min-width */
                  min-width: unset; /* Remove min-width constraint */
              }
              #addPaymentForm input[type="number"] { width: 80px;} /* Specific width */
              #addPaymentForm input[type="text"] { width: 150px;} /* Specific width */
        }


         #addPaymentForm button {
             margin: 0; padding: 6px 12px; font-size: 1em;
             border-color: var(--primary-color); color: var(--primary-color); background-color: transparent; width: 100%; /* Full width on small screens */
        }
          @media (min-width: 640px) { #addPaymentForm button { width: auto; flex-grow: 0; } } /* Auto width on larger screens */

        #addPaymentForm button:hover { background-color: var(--primary-color); color: white; }
        html.dark #addPaymentForm button { border-color:var(--primary-color-dark); color:var(--primary-color-dark); }
        html.dark #addPaymentForm button:hover { background-color:var(--primary-color-dark); color:var(--background-color); }


        #controlsHeader {
            display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;
            margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color);
        }
        #appTitle { margin: 0; font-size: 1.5em; }
        #topControls { display: flex; gap: 5px; align-items: center; flex-wrap: wrap;}
        #topControls button { margin: 0; padding: 4px 6px; font-size: 0.9em; }

        .control-icon { font-size: 1.2em; border: none; background: none; padding: 0; margin: 0; color: var(--text-color); }
        .control-icon:hover { color: var(--input-placeholder); background: none; border: none; }
        html.dark .control-icon {color:var(--text-color);} html.dark .control-icon:hover {color:var(--input-placeholder);}


        #quickMonthChangeBtn { border: none; background: none; padding: 0; margin: 0; font-size: 1.2em; cursor: pointer; color: var(--primary-color); }
        #quickMonthChangeBtn:hover { color: var(--link-color); }
        html.dark #quickMonthChangeBtn {color:var(--primary-color-dark);} html.dark #quickMonthChangeBtn:hover {color:var(--link-color);}

        .current-day-row { background-color: var(--current-day-bg); }

        #reminderArea {
             margin-top: 10px; padding: 8px;
             background-color: var(--reminder-bg); color: var(--reminder-text);
             border-radius: 4px; font-size: 0.9em; display: none; /* Initially hidden */
         }

         hr { border-color: var(--border-color); } /* Ensure hr uses border variable */

    </style>
</head>
<body class="">
     <div id="controlsHeader">
         <h1 id="appTitle" data-translate-key="appTitle">Attendance Tracker</h1>
         <div id="topControls">
             <button id="languageToggleBtn" onclick="toggleLanguage()" class="control-icon" data-translate-key-title="Change Language / भाषा बदलें">
                 <i class="fas fa-language"></i> <span id="currentLangDisplay"></span>
             </button>
             <button id="darkModeToggleBtn" onclick="toggleDarkMode()" class="control-icon" data-translate-key-title="Toggle Dark Mode / डार्क मोड टॉगल करें">
                 <i class="fas fa-moon"></i>
             </button>
             <button id="hideUsersBtn" onclick="toggleUsers()">
                 <span data-translate-key="hideShowNames">Hide/Show Names</span>
             </button>
             <button id="toggleDataManagementBtn" onclick="toggleDataMenu()" class="control-icon" data-translate-key-title="Data Management Options / डेटा प्रबंधन विकल्प">
                 <i class="fas fa-database"></i> </button>
         </div>
     </div>

    <div id="addUserInputContainer" class="container">
         <input type="text" id="newUserName" data-translate-key-placeholder="addNewNamePlaceholder" placeholder="Add New Name" style="flex-grow: 1;"> <button id="addUserBtn" onclick="addUser()">
            <span style="font-size: 20px;">➕</span>
         </button>
    </div>

    <div id="userTabs"></div>
    <div id="reminderArea"></div> <div id="dataManagementButtons"> <button id="exportDataBtn" onclick="exportData()" >
            <i class="fas fa-download"></i> <span data-translate-key="exportData">Export Data (JSON)</span>
        </button>
        <button id="importDataBtn" onclick="document.getElementById('importFileInput').click()" >
            <i class="fas fa-upload"></i> <span data-translate-key="importData">Import Data (JSON)</span>
        </button>
        <input type="file" id="importFileInput" accept=".json" onchange="handleFileUpload(event)" style="display:none;">
        <button id="clearDataBtn" onclick="clearAllData()" >
            <i class="fas fa-trash-alt"></i> <span data-translate-key="clearAllData">Clear All Data</span>
        </button>
        <button id="archiveUserBtn" onclick="toggleArchiveCurrentUser()" style="display: none;"></button> <button id="toggleArchivedUsersBtn" onclick="toggleArchivedUsers()" style="display: none;"></button> </div>

    <div id="importPreviewModal" class="modal">
        <div class="modal-content"> <div class="modal-header"> <span class="modal-title" data-translate-key="importPreviewTitle">Import Data Preview</span>
                <span class="close-button" onclick="closeImportModal()">&times;</span> </div>
            <div class="modal-body" id="importPreviewContent"></div>
            <div class="modal-footer">
                <button onclick="closeImportModal()" data-translate-key="cancel">Cancel</button>
                <button onclick="confirmImport('merge')" data-translate-key="mergeData">Merge Data</button>
                <button onclick="confirmImport('replace')" data-translate-key="replaceAllData">Replace All Data</button>
            </div>
        </div>
    </div>

    <div id="userControl"> <div> <h2 style="margin: 0;"><span data-translate-key="forUser">के लिए</span> <span id="selectedUserName"></span></h2>
        </div>

        <div id="userQuickControls">
             <div id="rateContainer">
                 <label for="userRate" data-translate-key="rateLabel">Rate (Per Attendance):</label>
                 <input type="number" id="userRate" min="0" data-translate-key-placeholder="rateLabel" placeholder="Rate">
             </div>

             <div id="overtimeRateContainer">
                 <label for="userOvertimeRate" data-translate-key="overtimeRateLabel">Overtime Hours per Attendance Rate:</label>
                 <input type="number" id="userOvertimeRate" min="1" step="0.5" data-translate-key-placeholder="otRatePlaceholder" placeholder="OT Rate">
             </div>

              <div id="manualBalanceContainer">
                 <label for="manualCarriedOverBalance" data-translate-key="manualBalanceLabel">Carried Over Balance:</label>
                 <input type="number" id="manualCarriedOverBalance" data-translate-key-placeholder="manualBalancePlaceholder" placeholder="Previous Balance">
              </div>

              <div id="includeBalanceContainer">
                  <label for="otherUserForReport" data-translate-key="includeBalanceOf">Include Balance of:</label>
                  <select id="otherUserForReport" onchange="showSummary(activeReportType)">
                      <option value="" selected disabled hidden data-translate-key="selectUserPlaceholder">-- Select User --</option>
                      </select>
              </div>
         </div>


        <div id="monthNavWrapper">
            <div id="monthNav">
                <button onclick="goToPreviousMonth()">❮ <span data-translate-key="previous">Previous</span></button>
                <div class="month-display-group">
                    <span id="currentMonthDisplay"></span>
                    <button id="quickMonthChangeBtn" onclick="promptQuickMonthChange()" title="Quick Change Month">⚡</button>
                </div>
                <button onclick="goToNextMonth()"><span data-translate-key="next">Next</span> ❯</button>
            </div>
        </div>

        <div id="viewReportButtonsWrapper">
            <button onclick="showSummary('firstHalfCurrent')"><span data-translate-key="first15Days">First 15 Days</span></button>
            <button onclick="showSummary('afterFifteenth')"><span data-translate-key="after15th">After 15th</span></button>
            <button onclick="showSummary('fullMonth')"><span data-translate-key="fullMonth">Full Month</span></button>
        </div>

        <div id="shareReportButtonWrapper">
            <button onclick="shareReport()">
                <span data-translate-key="shareReportImage">Share Report (Image)</span>
             </button>
         </div>
    </div>

     <div id="reportArea">
         <div id="tableContainer"></div>
         <div id="previousBalancePaymentsSection"> <h3 data-translate-key="prevBalancePaymentsTitle">Payments Received Towards Previous Balance</h3>
             <div id="paymentList"></div>
             <div id="addPaymentForm">
                  <label for="paymentAmount" data-translate-key="amountLabel">Amount:</label>
                  <input type="number" id="paymentAmount" data-translate-key-placeholder="amountPlaceholder" placeholder="Amount">
                  <label for="paymentNotes" data-translate-key="notesLabel">Notes:</label>
                  <input type="text" id="paymentNotes" data-translate-key-placeholder="notesPlaceholder" placeholder="Notes">
                  <button onclick="addPreviousBalancePayment()"><span data-translate-key="addPayment">Add Payment</span></button>
             </div>
        </div>
         <div id="summarySection"> </div>
        <div id="reportFooter"> </div>
    </div>

    <script>
        // --- Configuration ---
        // Translations object
        const translations = {
             'en': {
                appTitle: "Attendance Tracker", hideShowNames: "Hide/Show Names", dataManagement: "Data Management",
                 dataManagementOptions: "Data Management Options", exportData: "Export Data (JSON)", importData: "Data Import (JSON)",
                 clearAllData: "Clear All Data", chartsTitle: "Charts", forUser: "For", previous: "Previous", next: "Next",
                 first15Days: "First 15 Days", after15th: "After 15th", fullMonth: "Full Month",
                 shareReportImage: "Share Report (Image)", prevBalancePaymentsTitle: "Payments Received Towards Previous Balance",
                 amountLabel: "Amount:", dateLabel: "Date/Time:", notesLabel: "Notes:", addPayment: "Add Payment",
                 cancel: "Cancel", mergeData: "Merge Data", replaceAllData: "Replace All Data", attendanceHeader: "Attendance",
                 expensesHeader: "Expenses", rent: "Rent", food: "Food", received: "Received (Daily)", balance: "Balance",
                 addNewNamePlaceholder: "Add New Name", notesPlaceholder: "Notes", amountPlaceholder: "Amount",
                 promptMonthInput: "Enter Month (YYYY-MM):",
                 dateHeaderTbl: "Date", statusHeaderTbl: "Status", otHeaderTbl: "OT", rentHeaderTbl: "Rent", foodHeaderTbl: "Food", receivedHeaderTbl: "Received", notesHeaderTbl: "Notes", editedHeaderTbl: "Edited",
                 alertEnterName: "Please enter a name.", alertUserExists: "User '{name}' already exists (case-insensitive match)! Do you want to reactivate them?",
                 alertUserAdded: "User '{name}' added successfully!", alertSelectUserMonth: "Please select a user and month first.",
                 alertEnterValidAmount: "Please enter a valid positive amount.", alertPaymentAdded: "Payment added.", alertPaymentDeleted: "Payment deleted.",
                 confirmDeletePayment: "Are you sure you want to delete this payment of {amount}?",
                 alertGenerateReportFirst: "Please generate a report first by clicking one of the 'View Report' buttons.",
                 alertCannotGenerateImage: "Cannot generate report image without a selected user, month, or table data.",
                 alertWebShareFailed: "Sharing failed directly. Report image downloaded instead.", alertWebShareCancelled: "Web Share cancelled by user.",
                 alertImageDownloaded: "Report image generated. It should be downloaded to your device.", alertCouldNotGenerateImage: "Could not generate report image.",
                 confirmClearData: "Are you sure you want to delete ALL user data? This action cannot be undone.",
                 alertDataCleared: "All data has been cleared.", alertDataExported: "Data exported successfully! Your backup file is being downloaded.",
                 alertExportFailed: "Failed to export data. Error: {error}", alertNoFileSelected: "No file selected.",
                 alertSelectJsonFile: "Please select a JSON file.", alertImportProcessingError: "Failed to process import file: {error}",
                 alertFileReadError: "Error reading file.", alertInvalidImportFormat: "Invalid data format. Missing attendanceData object.",
                 alertNoImportData: "No import data available.", alertDataImported: "Data {mode} successfully!",
                 alertImportFailed: "Failed to import data: {error}", importPreviewTitle: "Data Import Preview",
                 importContainsUsers: "This data file contains information for <strong>{count}</strong> users:",
                 andMoreUsers: "...and {count} more users", currentData: "Current Data:",
                 youHaveUsers: "You currently have <strong>{count}</strong> users in your system.",
                 importChooseOption: "Please choose how to import this data:",
                 importOptionMerge: "Merge Data: Add new users and update existing ones",
                 importOptionReplace: "Replace All: Delete all current data and replace with imported data",
                 reportFor: "Report for {user} - {title}",
                 attendanceSummary: "Attendance: {days} days × {rate} = {total}",
                 overtimeSummary: "Overtime: {hours} hours → {amount} ({hoursPerDay} hours equals 1 Attendance Rate)", // Updated string
                 rentSummary: "Rent: {amount}", foodSummary: "Food: {amount}", currentPeriodGross: "Current Period Gross Total: {amount}",
                 carriedOverBalance: "Carried Over Balance from Previous Month: {amount}",
                 manualBalanceLabel: "Carried Over Balance:", manualBalancePlaceholder: "Enter Previous Balance",
                 totalOwed: "Total Amount Owed (Gross + Carried Over Balance): {amount}",
                 totalReceivedDaily: "Total Received (Daily Entries this Period): {amount}",
                 totalReceivedPrevBalance: "Total Received (Towards Previous Balance): {amount}",
                 totalAllReceived: "Total ALL Received (This Period): {amount}", finalBalanceDue: "Final Balance Due: {amount}",
                 reportTitleFull: "{year} {month} ({days} days) Report", reportTitleFirstHalf: "{year} {month} First {days} Days Report",
                 reportTitleAfterFifteenth: "{year} {month} Report After 15th ({days} days)",
                 reportGeneratedOn: "Report for {user} ({monthYear}{period}) - Generated on {dateTime}\nFinal Balance Due: {balance}{otherUserBalanceString}",
                 reportPeriodFirstHalf: " (First 15 Days)", reportPeriodAfter15th: " (After 15th)", reportPeriodFullMonth: " (Full Month)",
                 reminderFinalize: "Month is ending soon. Remember to finalize reports.",
                 noPaymentsRecorded: "no payments recorded for this month.", noDataForMonth: "No or invalid data structure available for {monthKey}.",
                 pleaseSelectUser: "Please select a user first.", errorInvalidMonthKey: "Error: Invalid month data key \"{monthKey}\".",
                 invalidMonth: "Invalid Month", alertInvalidMonthFormat: "Invalid month format. Please use CIRCA-MM (e.g., 2023-10).",
                 alertMonthDoesNotExist: "No data available for month {monthKey}.", noDate: "No Date/Time", autoSaveStatus: "Auto-saved {time} ago",
                 confirmArchiveUser: "Are you sure you want to archive user '{name}'? Their data will be saved but they won't appear in the main list until you click 'Show Archived Users'.",
                 alertUserArchived: "User '{name}' has been archived. You can see them by clicking 'Show Archived Users'.",
                 confirmReactivateUser: "User '{name}' is currently archived. Do you want to reactivate them?",
                 alertUserReactivated: "User '{name}' has been reactivated.", showOptions: "Show Options", hideOptions: "Hide Options",
                 showArchived: "Show Archived", hideArchived: "Hide Archived", archiveUser: "Archive User", reactivateUser: "Reactivate User",
                 cannotGoToFutureMonth: "Cannot navigate to a future month relative to the current system date.",

                 // New translations for include balance feature
                 includeBalanceOf: "Include Balance of:",
                 otherUserPeriodEarnings: "Period Earnings for {otherUser}: {amount}", // Keep this translation key in case it's useful elsewhere or for debugging, but won't be used in the primary summary view of included user.
                 otherUserPeriodReceived: "Period Received (Daily) for {otherUser}: {amount}", // Keep this translation key
                 otherUserPeriodNet: "Period Net for {otherUser} ({earnings} - {received}): {amount}", // Keep this translation key
                 otherUserFinalBalance: "Final Balance Due for {otherUser}: {amount}", // NEW: For showing other user's final balance in summary
                 combinedFinalBalance: "Combined Final Balance Due ({currentUser} + {otherUser}'s Final Balance): {amount}", // Updated combined text
                 // footerOtherUserBalance: "\n({otherUser}'s Period Net: {otherUserPeriodNet}) \nCombined Balance: {combinedBalance}", // Keep the old one just in case, but use the new one below
                 footerIncludeOtherUserFinalBalance: "\n(Including {otherUser}'s Final Balance: {otherUserFinalBalance}) \nCombined Balance: {combinedBalance}", // NEW: For footer text when including other user's final balance

                 // New translation for Overtime Rate label and placeholders
                 overtimeRateLabel: "Overtime Hours per Attendance Rate:",
                 otRatePlaceholder: "OT Rate", // Placeholder for Overtime Rate input
                 selectUserPlaceholder: "-- Select User --" // Placeholder for Include Balance select
            },
             'hi': {
                appTitle: "हाज़िरी ट्रैकर", hideShowNames: "नाम छिपाएँ/दिखाएँ", dataManagement: "डेटा प्रबंधन",
                 dataManagementOptions: "डेटा प्रबंधन विकल्प", exportData: "डेटा एक्सपोर्ट करें (JSON)", importData: "डेटा इम्पोर्ट करें (JSON)",
                 clearAllData: "सारा डेटा साफ़ करें", chartsTitle: "चार्ट", forUser: "के लिए", previous: "पिछला", next: "अगला",
                 first15Days: "पहले 15 दिन", after15th: "15 तारीख के बाद", fullMonth: "पूरा महीना",
                 shareReportImage: "रिपोर्ट शेयर करें (इमेज)", prevBalancePaymentsTitle: "पिछले बैलेंस के लिए प्राप्त भुगतान",
                 amountLabel: "राशि:", dateLabel: "तारीख/समय:", notesLabel: "टिप्पणियाँ:", addPayment: "भुगतान जोड़ें",
                 cancel: "रद्द करें", mergeData: "डेटा मर्ज करें", replaceAllData: "सारा डेटा बदलें", attendanceHeader: "हाज़िरी",
                 expensesHeader: "खर्च", rent: "किराया", food: "खाना", received: "प्राप्त (रोजाना)", balance: "बैलेंस",
                 addNewNamePlaceholder: "नया नाम जोड़ें", notesPlaceholder: "टिप्पणियाँ", amountPlaceholder: "राशि",
                 promptMonthInput: "महीना दर्ज करें (YYYY-MM):",
                 dateHeaderTbl: "तारीख", statusHeaderTbl: "स्थिति", otHeaderTbl: "ओटी", rentHeaderTbl: "किराया", foodHeaderTbl: "खाना", receivedHeaderTbl: "प्राप्त", notesHeaderTbl: "टिप्पणियाँ", editedHeaderTbl: "संपादित",
                 alertEnterName: " कृपया एक नाम दर्ज करें।", alertUserExists: "यूज़र '{name}' पहले से मौजूद है! क्या आप उन्हें फिर से सक्रिय करना चाहते हैं?",
                 alertUserAdded: "यूज़र '{name}' सफलतापूर्वक जोड़ा गया!", alertSelectUserMonth: "कृपया पहले एक यूज़र और महीना चुनें।",
                 alertEnterValidAmount: " कृपया एक मान्य सकारात्मक राशि दर्ज करें।", alertPaymentAdded: "भुगतान जोड़ा गया।", alertPaymentDeleted: " भुगतान हटाया गया।",
                 confirmDeletePayment: "क्या आप निश्चित हैं कि आप {amount} का यह भुगतान हटाना चाहते हैं?",
                 alertGenerateReportFirst: "कृपया पहले 'रिपोर्ट देखें' बटनों में से किसी एक पर क्लिक करके रिपोर्ट जनरेट करें।",
                 alertCannotGenerateImage: "चुने हुए यूज़र, महीने, या तालिका डेटा के बिना रिपोर्ट इमेज जनरेट नहीं की जा सकती।",
                 alertWebShareFailed: "सीधा शेयर विफल रहा। रिपोर्ट इमेज इसके बजाय डाउनलोड की गई।", alertWebShareCancelled: "यूज़र द्वारा वेब शेयर रद्द किया गया।",
                 alertImageDownloaded: "रिपोर्ट इमेज जनरेट की गई। इसे आपके डिवाइस पर डाउनलोड होना चाहिए।", alertCouldNotGenerateImage: "रिपोर्ट इमेज जनरेट नहीं हो सकी।",
                 confirmClearData: "क्या आप निश्चित हैं कि आप **सारा** यूज़र डेटा हटाना चाहते हैं? यह कार्रवाई पूर्ववत नहीं की जा सकती।",
                 alertDataCleared: "सारा डेटा साफ़ कर दिया गया है।", alertDataExported: "डेटा सफलतापूर्वक एक्सपोर्ट किया गया! आपकी बैकअप फ़ाइल डाउनलोड हो रही है।",
                 alertExportFailed: "डेटा एक्सपोर्ट विफल रहा: त्रुटि: {error}", alertNoFileSelected: "कोई फ़ाइल नहीं चुनी गई।",
                 alertSelectJsonFile: "कृपया एक JSON फ़ाइल चुनें।", alertImportProcessingError: "इम्पोर्ट फ़ाइल को प्रोसेस करने में विफल रहा: {error}",
                 alertFileReadError: "फ़ाइल पढ़ने में त्रुटि।", alertInvalidImportFormat: "अमान्य डेटा प्रारूप। attendanceData ऑब्जेक्ट गायब है।",
                 alertNoImportData: "कोई इम्पोर्ट डेटा उपलब्ध नहीं है।", alertDataImported: "डेटा सफलतापूर्वक {mode} किया गया!",
                 alertImportFailed: "डेटा इम्पोर्ट विफल रहा: त्रुटि: {error}", importPreviewTitle: "डेटा इम्पोर्ट पूर्वावलोकन",
                 importContainsUsers: "इस डेटा फ़ाइल में <strong>{count}</strong> यूज़र की जानकारी है:",
                 andMoreUsers: "...और {count} अन्य यूज़र", currentData: "वर्तमान डेटा:",
                 youHaveUsers: "आपके सिस्टम में वर्तमान में <strong>{count}</strong> यूज़र हैं।",
                 importChooseOption: "कृपया चुनें कि इस डेटा को कैसे इम्पोर्ट करें:",
                 importOptionMerge: "डेटा मर्ज करें: नए यूज़र जोड़ें और मौजूदा यूज़र को अपडेट करें",
                 importOptionReplace: "सब बदलें: वर्तमान सारा डेटा हटाएँ और इम्पोर्ट किए गए डेटा से बदलें",
                 reportFor: "{user} के लिए रिपोर्ट - {title}",
                 attendanceSummary: "हाज़िरी: {days} दिन × {rate} = {total}",
                 overtimeSummary: "ओवरटाइम: {hours} घंटे → {amount} ({hoursPerDay} घंटे 1 हाज़िरी दर के बराबर)", // Updated string
                 rentSummary: "किराया: {amount}", foodSummary: "खाना: {amount}", currentPeriodGross: "वर्तमान अवधि का सकल योग: {amount}",
                 carriedOverBalance: "पिछले महीने से लाया गया बैलेंस: {amount}",
                 manualBalanceLabel: "लाया गया बैलेंस:", manualBalancePlaceholder: "पिछला बैलेंस दर्ज करें",
                 totalOwed: "कुल देय राशि (सकल + लाया गया बैलेंस): {amount}",
                 totalReceivedDaily: "कुल प्राप्त (इस अवधि की रोज़ाना प्रविष्टियाँ): {amount}",
                 totalReceivedPrevBalance: "कुल प्राप्त (पिछले बैलेंस के लिए): {amount}",
                 totalAllReceived: "कुल सभी प्राप्त (इस अवधि): {amount}", finalBalanceDue: "अंतिम देय बैलेंस: {amount}",
                 reportTitleFull: "{year} {month} ({days} दिन) रिपोर्ट", reportTitleFirstHalf: "{year} {month} के पहले {days} दिन की रिपोर्ट",
                 reportTitleAfterFifteenth: "{year} {month} की 15 तारीख के बाद की रिपोर्ट ({days} दिन)",
                 reportGeneratedOn: "{user} के लिए रिपोर्ट ({monthYear}{period}) - {dateTime} को जनरेट की गई\nअंतिम देय बैलेंस: {balance}{otherUserBalanceString}",
                 reportPeriodFirstHalf: " (पहले 15 दिन)", reportPeriodAfter15th: " (15 तारीख के बाद)", reportPeriodFullMonth: " (पूरा महीना)",
                 reminderFinalize: "महीना जल्द ही समाप्त हो रहा है। रिपोर्ट को अंतिम रूप देना याद रखें।",
                 noPaymentsRecorded: "इस महीने के लिए कोई भुगतान दर्ज नहीं किया गया।", noDataForMonth: "{monthKey} के लिए कोई या अमान्य डेटा संरचना उपलब्ध नहीं है।",
                 pleaseSelectUser: "कृपया पहले एक यूज़र चुनें।", errorInvalidMonthKey: "त्रुटि: अमान्य महीना डेटा कुंजी \"{monthKey}\"।",
                 invalidMonth: "अमान्य महीना", alertInvalidMonthFormat: "अमान्य महीना प्रारूप। कृपया CIRCA-MM (जैसे, 2023-10) का उपयोग करें।",
                 alertMonthDoesNotExist: "महीना {monthKey} के लिए कोई डेटा उपलब्ध नहीं है।", noDate: "कोई तारीख/समय नहीं", autoSaveStatus: "{time} पहले ऑटो-सेव हुआ",
                 confirmArchiveUser: "क्या आप निश्चित हैं कि आप यूज़र '{name}' को संग्रहित (archive) करना चाहते हैं? उनका डेटा सहेजा जाएगा लेकिन जब तक आप 'संग्रहित यूज़र दिखाएँ' पर क्लिक नहीं करते, वे मुख्य सूची में दिखाई नहीं देंगे।",
                 alertUserArchived: "यूज़र '{name}' को संग्रहित कर दिया गया है। आप उन्हें 'संग्रहित यूज़र दिखाएँ' पर क्लिक करके देख सकते हैं।",
                 confirmReactivateUser: "यूज़र '{name}' वर्तमान में संग्रहित है। क्या आप उन्हें फिर से सक्रिय करना चाहते हैं?",
                 alertUserReactivated: "यूज़र '{name}' को फिर से सक्रिय कर दिया गया है।", showOptions: "विकल्प दिखाएँ", hideOptions: "विकल्प छिपाएँ",
                 showArchived: "संग्रहित दिखाएँ", hideArchived: "संग्रहित छिपाएँ", archiveUser: "यूज़र संग्रहित करें", reactivateUser: "यूज़र फिर से सक्रिय करें",
                 cannotGoToFutureMonth: "सिस्टम की वर्तमान तारीख से भविष्य के महीने में नहीं जा सकते।",

                 // New translations for include balance feature
                 includeBalanceOf: "शामिल करें बैलेंस किसका:",
                 otherUserPeriodEarnings: "पीरियड कमाई {otherUser} के लिए: {amount}", // Keep
                 otherUserPeriodReceived: "पीरियड प्राप्त (रोजाना) {otherUser} के लिए: {amount}", // Keep
                 otherUserPeriodNet: "पीरियड नेट {otherUser} के लिए ({earnings} - {received}): {amount}", // Keep
                 otherUserFinalBalance: "{otherUser} का अंतिम देय बैलेंस: {amount}", // NEW: For showing other user's final balance in summary
                 combinedFinalBalance: "संयुक्त अंतिम देय बैलेंस ({currentUser} + {otherUser} का अंतिम बैलेंस): {amount}", // Updated combined text
                 // footerOtherUserBalance: "\n({otherUser}'s Period Net: {otherUserPeriodNet}) \nCombined Balance: {combinedBalance}", // Keep the old one just in case
                 footerIncludeOtherUserFinalBalance: "\n({otherUser} का अंतिम बैलेंस शामिल है: {otherUserFinalBalance}) \nसंयुक्त बैलेंस: {combinedBalance}", // NEW: For footer text when including other user's final balance

                 // New translation for Overtime Rate label and placeholders
                 overtimeRateLabel: "ओवरटाइम घंटे प्रति हाज़िरी दर:",
                 otRatePlaceholder: "ओटी दर", // Placeholder for Overtime Rate input
                 selectUserPlaceholder: "-- यूज़र चुनें --" // Placeholder for Include Balance select
            }
        };
        let currentLanguage = localStorage.getItem('appLanguage') || 'hi';
        let data = {};
        let currentUser = null;
        let currentlyViewedMonth = null;
        let activeReportType = 'fullMonth';
        let finalBalanceForReport = 0; // This will now hold the CURRENT user's final balance initially
        let combinedFinalBalanceForReport = 0; // New variable for the combined balance
        // let otherUserPeriodNetForReport = 0; // Removed - replaced by otherUserFinalBalanceForReport
        let otherUserFinalBalanceForReport = 0; // NEW: To store the other user's final balance when included
        let importDataBuffer = null;
        let showArchivedUsers = false;

        const RENDER_DELAY = 350;
        let renderTimeout = null;

        function translate(key, params = {}) {
            let text = translations[currentLanguage]?.[key] || translations['en']?.[key] || key;
             for (const param in params) {
                 text = text.replace(`{${param}}`, params[param]);
             }
             return text;
        }

        function applyTranslationsToUI() {
             document.querySelectorAll('[data-translate-key]').forEach(element => {
                 element.textContent = translate(element.getAttribute('data-translate-key'));
             });
             document.querySelectorAll('[data-translate-key-placeholder]').forEach(element => {
                  element.placeholder = translate(element.getAttribute('data-translate-key-placeholder'));
             });
              document.querySelectorAll('[data-translate-key-title]').forEach(element => {
                  element.title = translate(element.getAttribute('data-translate-key-title'));
             });
             const hideUsersBtn = document.getElementById('hideUsersBtn');
             if (hideUsersBtn) {
                  hideUsersBtn.querySelector('span').textContent = translate('hideShowNames');
                   // Visibility is handled by renderUserTabs
             }
              const langDisplay = document.getElementById('currentLangDisplay');
              if (langDisplay) langDisplay.textContent = currentLanguage.toUpperCase();

              const tableHead = document.querySelector('#tableContainer thead tr');
               if (tableHead) {
                    const headers = tableHead.querySelectorAll('th');
                    if(headers.length >= 8) { // Ensure there are enough headers
                        headers[0].textContent = translate('dateHeaderTbl');
                        headers[1].textContent = translate('statusHeaderTbl');
                        headers[2].textContent = translate('otHeaderTbl');
                        headers[3].textContent = translate('rentHeaderTbl');
                        headers[4].textContent = translate('foodHeaderTbl');
                        headers[5].textContent = translate('receivedHeaderTbl');
                        headers[6].textContent = translate('notesHeaderTbl');
                        headers[7].textContent = translate('editedHeaderTbl');
                    }
               }
               updateMonthDisplay(); // After other static translations

                // Update Archive/Reactivate button (now in dataManagementButtons)
                const archiveUserBtn = document.getElementById('archiveUserBtn');
                if (archiveUserBtn && currentUser && data[currentUser]) {
                    const isArchived = data[currentUser].isActive === false;
                    archiveUserBtn.textContent = translate(isArchived ? 'reactivateUser' : 'archiveUser');
                    archiveUserBtn.className = ''; // Clear existing style classes
                    archiveUserBtn.classList.add(isArchived ? 'reactivate-style' : 'archive-style');
                    // Visibility is handled by toggleDataMenu and selectUser
                } else if (archiveUserBtn) {
                     archiveUserBtn.style.display = 'none'; // Hide if no current user
                }

                const toggleArchivedBtn = document.getElementById('toggleArchivedUsersBtn');
                if (toggleArchivedBtn) {
                    toggleArchivedBtn.textContent = showArchivedUsers ? translate('hideArchived') : translate('showArchived');
                    // Visibility handled by toggleDataMenu and other logic
                }

                 const rateLabel = document.querySelector('label[for="userRate"]');
                 if (rateLabel) rateLabel.textContent = translate('rateLabel');

                 // New translation for Overtime Rate label
                 const overtimeRateLabel = document.querySelector('label[for="userOvertimeRate"]');
                 if(overtimeRateLabel) overtimeRateLabel.textContent = translate('overtimeRateLabel');


                 const manualBalanceLabel = document.querySelector('label[for="manualCarriedOverBalance"]');
                 if (manualBalanceLabel) manualBalanceLabel.textContent = translate('manualBalanceLabel');

                 // New translation for include balance label
                 const includeBalanceLabel = document.querySelector('label[for="otherUserForReport"]');
                 if(includeBalanceLabel) includeBalanceLabel.textContent = translate('includeBalanceOf');

                 // Translate the placeholder option for the select
                 const selectPlaceholderOption = document.querySelector('#otherUserForReport option[disabled][hidden]');
                 if(selectPlaceholderOption) selectPlaceholderOption.textContent = translate('selectUserPlaceholder');


                 // Translate modal title
                 const importPreviewTitle = document.querySelector('.modal-title[data-translate-key="importPreviewTitle"]');
                 if(importPreviewTitle) importPreviewTitle.textContent = translate('importPreviewTitle');
         }

        function toggleLanguage() {
            currentLanguage = (currentLanguage === 'en') ? 'hi' : 'en';
            localStorage.setItem('appLanguage', currentLanguage);
            document.documentElement.lang = currentLanguage;
            applyTranslationsToUI();
            // Re-render parts that depend heavily on language formatting (like dates in table/payments, summary)
             scheduleFullRender(100);
        }
        function setDarkMode(isDark) {
            const htmlElement = document.documentElement;
             const toggleIcon = document.getElementById('darkModeToggleBtn')?.querySelector('i');
             if (isDark) {
                 htmlElement.classList.add('dark');
                 localStorage.setItem('darkMode', 'enabled');
                 if(toggleIcon) { toggleIcon.classList.remove('fa-moon'); toggleIcon.classList.add('fa-sun'); }
             } else {
                 htmlElement.classList.remove('dark');
                 localStorage.setItem('darkMode', 'disabled');
                 if(toggleIcon) { toggleIcon.classList.remove('fa-sun'); toggleIcon.classList.add('fa-moon'); }
             }
             // Re-render to apply potential dark mode specific rendering logic (like placeholder icons)
              scheduleFullRender(100);
        }
        function toggleDarkMode() { setDarkMode(!document.documentElement.classList.contains('dark')); }
        // Apply dark mode preference on load
        if (localStorage.getItem('darkMode') === 'enabled') setDarkMode(true); else setDarkMode(false);

        function checkReminders() {
            const reminderDiv = document.getElementById('reminderArea');
              if (!reminderDiv) return;
              if (!currentUser || (data[currentUser] && data[currentUser].isActive === false)) {
                  reminderDiv.style.display = 'none'; return;
              }
              // Use the currently viewed month, not necessarily the current system month
              if (!currentlyViewedMonth) { reminderDiv.style.display = 'none'; return; }
              const [year, monthNum] = currentlyViewedMonth.split('-').map(Number);
              const today = new Date();
              const currentSystemYear = today.getFullYear();
              const currentSystemMonth = today.getMonth() + 1;

              // Only show reminder if viewing the current system month
              if (year === currentSystemYear && monthNum === currentSystemMonth) {
                  const endOfMonth = new Date(year, monthNum, 0).getDate(); // Last day of the month
                  const currentDayOfMonth = today.getDate();
                  if (endOfMonth - currentDayOfMonth <= 3 && endOfMonth - currentDayOfMonth >= 0) {
                       reminderDiv.textContent = translate('reminderFinalize');
                       reminderDiv.style.display = 'block';
                   } else {
                       reminderDiv.style.display = 'none';
                   }
              } else {
                  reminderDiv.style.display = 'none'; // Hide if not viewing current system month
              }
        }

        function fullRender() {
             console.log("fullRender called", {currentUser, currentlyViewedMonth}); // Debugging
             const userControl = document.getElementById("userControl");
             const tableContainer = document.getElementById("tableContainer");
             const summarySection = document.getElementById("summarySection");
             const paymentsSection = document.getElementById('previousBalancePaymentsSection');
             const footerDiv = document.getElementById('reportFooter');
             const quickChange = document.getElementById('quickMonthChangeBtn');
             // Access the new quick controls container
             const userQuickControls = document.getElementById('userQuickControls');


             if (!currentUser || !currentlyViewedMonth || !data[currentUser]) { // Check data[currentUser] too
                 console.log("fullRender: No user or month selected, hiding sections."); // Debugging
                 userControl.style.display = "none";
                 tableContainer.innerHTML = "";
                 summarySection.innerHTML = "";
                 paymentsSection.style.display = 'none';
                 if(footerDiv) footerDiv.textContent = '';
                 document.getElementById('currentMonthDisplay').textContent = '';

                 if(quickChange) quickChange.style.display = 'none';
                  // Hide the new quick controls container
                 if(userQuickControls) userQuickControls.style.display = 'none';


                 // Hide Archive button if data menu is open but no user selected
                 const dataManagementButtons = document.getElementById('dataManagementButtons');
                 const archiveBtn = document.getElementById('archiveUserBtn');
                 if ((dataManagementButtons.style.display === 'flex' || dataManagementButtons.style.display === 'block') && archiveBtn) {
                     archiveBtn.style.display = 'none';
                 }

                 checkReminders(); // Check and potentially hide reminder if no user
                 return;
             }

             // Ensure userControl and paymentsSection are visible if user and month are selected
             userControl.style.display = "block";
             paymentsSection.style.display = 'block';
             if(quickChange) quickChange.style.display = 'inline-block';
             // Show the new quick controls container
             if(userQuickControls) userQuickControls.style.display = 'flex';


             renderTable(currentlyViewedMonth);
             showSummary(activeReportType);
             checkReminders();
             // applyTranslationsToUI is called here to update text/styles after rendering
             // It also updates the Archive button text/style if visible
             applyTranslationsToUI();
             console.log("fullRender: Render complete for", {currentUser, currentlyViewedMonth}); // Debugging
        }
        function scheduleFullRender(delay = RENDER_DELAY) { if (renderTimeout) clearTimeout(renderTimeout); renderTimeout = setTimeout(fullRender, delay); }

        function loadData() {
             console.log("loadData called"); // Debugging
            const storedData = localStorage.getItem('attendanceData');
             if (storedData) {
                 try {
                      data = JSON.parse(storedData);
                       if (typeof data !== 'object' || data === null) data = {};
                       else {
                           let migrationNeeded = false;
                           // Migration logic - added checks for null/undefined objects and new fields
                            for(const userName in data) {
                                if(data[userName] && typeof data[userName] === 'object') {
                                    if(data[userName].rate === undefined) { data[userName].rate = 0; migrationNeeded = true; }
                                     // Add/migrate overtimeRate field, default to 8 if missing or invalid
                                    if(data[userName].overtimeRate === undefined || typeof data[userName].overtimeRate !== 'number' || data[userName].overtimeRate <= 0) {
                                         data[userName].overtimeRate = 8; migrationNeeded = true;
                                    }

                                    if(data[userName].isActive === undefined) { data[userName].isActive = true; migrationNeeded = true; }
                                    if(data[userName].months === undefined) { data[userName].months = {}; migrationNeeded = true; }

                                    // Ensure months is an object before iterating
                                    if (data[userName].months && typeof data[userName].months === 'object') {
                                        for(const monthKey in data[userName].months) {
                                            if(data[userName].months[monthKey] && typeof data[userName].months[monthKey] === 'object') {
                                                if(typeof data[userName].months[monthKey].carriedOverBalance !== 'number') { data[userName].months[monthKey].carriedOverBalance = 0; migrationNeeded = true; }
                                                if(!Array.isArray(data[userName].months[monthKey].previousBalancePayments)) { data[userName].months[monthKey].previousBalancePayments = []; migrationNeeded = true; }
                                                if(!Array.isArray(data[userName].months[monthKey].days)) { data[userName].months[monthKey].days = []; migrationNeeded = true; }

                                                const daysArray = data[userName].months[monthKey].days;
                                                if(Array.isArray(daysArray)) {
                                                     for(let i = 0; i < daysArray.length; i++) {
                                                         let day = daysArray[i];
                                                          // Ensure day is an object before accessing properties
                                                          if (!day || typeof day !== 'object') { day = {}; daysArray[i] = day; migrationNeeded = true; }
                                                           if(day.date === undefined) { const [y,m] = monthKey.split('-'); day.date = `${i+1}/${parseInt(m)}/${parseInt(y)}`; migrationNeeded = true; }
                                                           if(day.status === undefined) { day.status = ''; migrationNeeded = true; }
                                                           if(day.overtime === undefined) { day.overtime = 0; migrationNeeded = true; }
                                                           if(day.rent === undefined) { day.rent = 0; migrationNeeded = true; }
                                                           if(day.food === undefined) { day.food = 0; migrationNeeded = true; }
                                                           if(day.received === undefined) { day.received = 0; migrationNeeded = true; }
                                                           if(day.notes === undefined) { day.notes = ''; migrationNeeded = true; }
                                                           if(day.updated === undefined) { day.updated = ''; migrationNeeded = true; }
                                                           if (day.location !== undefined) { delete day.location; migrationNeeded = true; } // Remove location field
                                                     }
                                                }
                                            } else { // If month data is corrupted
                                                 data[userName].months[monthKey] = { carriedOverBalance: 0, previousBalancePayments: [], days: [] }; migrationNeeded = true;
                                            }
                                        }
                                    }
                                } else { // If user data is corrupted
                                     delete data[userName]; migrationNeeded = true; // Or initialize with defaults? Deleting might be safer for corrupted top-level user objects.
                                }
                            }
                           if (migrationNeeded) {
                                console.log("Data migration performed."); // Debugging
                                saveData(); // Save migrated data
                            }
                       }
                 } catch (e) { console.error("Error parsing data:", e); alert(translate('alertImportProcessingError', {error: e.message})); data = {}; }
             } else data = {};

             console.log("Data loaded:", data); // Debugging
             renderUserTabs();
             applyTranslationsToUI(); // Apply initial translations

             const lastUser = localStorage.getItem('lastSelectedUser');
             if(lastUser && data[lastUser] && data[lastUser].isActive !== false) { // Ensure last user exists and is active
                 console.log("Selecting last user:", lastUser); // Debugging
                 selectUser(lastUser);
             }
             else {
                 console.log("No last user or user not found/active. Resetting state."); // Debugging
                 currentUser = null;
                 currentlyViewedMonth = null;
                 localStorage.removeItem('lastSelectedUser'); // Clear invalid last user
                 fullRender(); // Clear view if no user is selected
             }
             checkReminders(); // Initial reminder check
        }
        function saveData() { /* ... same ... */ try { localStorage.setItem('attendanceData', JSON.stringify(data)); console.log("Data auto-saved."); } catch (e) { console.error("Error saving data:", e); } }

        function addUser() {
             console.log("addUser called"); // Debugging
            const nameInput = document.getElementById("newUserName");
             const name = nameInput.value.trim();
             if (!name) { alert(translate('alertEnterName')); return; }

             // Check for existing user (case-insensitive)
             const existingUserName = Object.keys(data).find(key => key.toLowerCase() === name.toLowerCase());

             if (existingUserName) {
                 const existingUser = data[existingUserName];
                 if (existingUser.isActive === false) {
                      if (confirm(translate('confirmReactivateUser', { name: existingUserName }))) {
                          existingUser.isActive = true;
                          saveData();
                          alert(translate('alertUserReactivated', { name: existingUserName }));
                          nameInput.value = "";
                          renderUserTabs();
                          selectUser(existingUserName); // Select the reactivated user
                          return;
                      } else {
                          nameInput.value = "";
                          return;
                      }
                 } else {
                     alert(translate('alertUserExists', { name: existingUserName }).split('?')[0]); // Show message without the reactivation question part
                     nameInput.value = "";
                     return;
                 }
             }

             // Add new user with default overtimeRate
             const formattedName = name.toLowerCase().split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
             data[formattedName] = { rate: 0, overtimeRate: 8, months: {}, isActive: true };
             saveData();
             alert(translate('alertUserAdded', {name: formattedName}));
             nameInput.value = "";
             renderUserTabs(); // Render tabs first
             selectUser(formattedName); // Then select the new user
        }

        function toggleArchiveCurrentUser() {
            if (!currentUser || !data[currentUser]) { /* alert(translate('pleaseSelectUser')); */ return; } // Button should be hidden if no user
            const user = data[currentUser];
            const isArchived = user.isActive === false;
            const confirmAction = isArchived ? confirm(translate('confirmReactivateUser', { name: currentUser })) : confirm(translate('confirmArchiveUser', { name: currentUser }));

            if (confirmAction) {
                user.isActive = !isArchived;
                saveData();
                alert(translate(isArchived ? 'alertUserReactivated' : 'alertUserArchived', { name: currentUser }));

                // Decide what to do after archiving/reactivating
                if (!user.isActive && !showArchivedUsers) {
                    // User was archived and archived users are hidden
                    currentUser = null;
                    currentlyViewedMonth = null;
                    localStorage.removeItem('lastSelectedUser');
                    fullRender(); // Clear the display
                    renderUserTabs(); // Update tabs to reflect removal from active list
                } else {
                    // User was reactivated or archived but archived users are shown
                    renderUserTabs(); // Update tab appearance (active/archived class)
                    selectUser(currentUser); // Re-select the user to refresh display
                }

                // Update the button text and visibility within the data menu
                const dataManagementButtons = document.getElementById('dataManagementButtons');
                if (dataManagementButtons.style.display === 'flex' || dataManagementButtons.style.display === 'block') {
                    const archiveBtn = document.getElementById('archiveUserBtn');
                    if (archiveBtn) {
                        if (currentUser && data[currentUser]) { // Re-check if currentUser is still set
                             archiveBtn.style.display = 'inline-block';
                             applyTranslationsToUI(); // Update text and style based on current user
                        } else {
                             archiveBtn.style.display = 'none'; // Hide if user became null
                        }
                    } else { console.warn("Archive user button not found."); } // Debugging

                     // Also update the Show/Hide Archived button text via translations
                    const toggleArchivedBtn = document.getElementById('toggleArchivedUsersBtn');
                    if (toggleArchivedBtn) {
                        const hasArchived = Object.values(data).some(u => u.isActive === false);
                        toggleArchivedBtn.style.display = hasArchived || showArchivedUsers ? 'inline-block' : 'none';
                        applyTranslationsToUI(); // Update text (Show/Hide Archived)
                    } else { console.warn("Toggle archived users button not found."); } // Debugging
                }
                 checkReminders(); // Re-check reminders
            }
        }
        function toggleArchivedUsers() {
             console.log("toggleArchivedUsers called"); // Debugging
             showArchivedUsers = !showArchivedUsers;
             renderUserTabs(); // Re-render tabs to show/hide archived users

             // If currently selected user is archived and we are now hiding archived, clear selection
             if (currentUser && data[currentUser]?.isActive === false && !showArchivedUsers) {
                 console.log("Selected user is archived and hiding archived users. Clearing selection."); // Debugging
                 currentUser = null;
                 currentlyViewedMonth = null;
                 localStorage.removeItem('lastSelectedUser');
                 fullRender(); // Clear display
             } else if (currentUser && data[currentUser]?.isActive !== false && showArchivedUsers) {
                 // If user is active and we are now showing archived, just re-render tabs. No need to re-select user unless they were previously archived and now visible.
                 // The logic above handles clearing if hiding. If showing, the user stays selected if active.
                 console.log("Selected user is active and showing archived users. Tabs re-rendered."); // Debugging
             } else if (!currentUser && showArchivedUsers) {
                 // If no user selected and we are now showing archived, check if the last user was archived and now visible
                  const lastUser = localStorage.getItem('lastSelectedUser');
                 if(lastUser && data[lastUser] && data[lastUser].isActive === false) {
                      console.log("No user selected, but last user was archived and now visible. Auto-selecting."); // Debugging
                      selectUser(lastUser); // Auto-select the last archived user if now visible
                 } else {
                      console.log("No user selected and showing archived users, but no archived user found or last user not archived."); // Debugging
                 }
             } else {
                console.log("toggleArchivedUsers: State changed, but current user status doesn't require clearing/re-selection."); // Debugging
             }

             // Ensure "Show Archived" button is visible if there are archived users
             const toggleArchivedBtn = document.getElementById('toggleArchivedUsersBtn');
             if (toggleArchivedBtn) {
                const hasArchived = Object.values(data).some(u => u.isActive === false);
                toggleArchivedBtn.style.display = hasArchived || showArchivedUsers ? 'inline-block' : 'none';
             }
             applyTranslationsToUI(); // Update the "Show Archived" button text

        }

        function populateOtherUserDropdown() {
            console.log("populateOtherUserDropdown called"); // Debugging
            const selectElement = document.getElementById('otherUserForReport');
            if (!selectElement) {
                 console.warn("otherUserForReport select element not found."); // Debugging
                 return;
            }

            // Clear existing options except the placeholder
            selectElement.querySelectorAll('option:not([disabled][hidden])').forEach(option => option.remove());

            const activeUserNames = Object.keys(data)
                .filter(name => data[name] && data[name].isActive !== false) // Filter active users
                .sort((a, b) => a.localeCompare(b));

            activeUserNames.forEach(name => {
                if (name !== currentUser) { // Exclude the currently selected user
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    selectElement.appendChild(option);
                }
            });

             // Reset the select value if the currently selected other user was the main user, or is no longer in the list
            const currentSelectedOtherUser = selectElement.value;
             if (currentSelectedOtherUser === currentUser || !activeUserNames.includes(currentSelectedOtherUser)) {
                 selectElement.value = ""; // Reset to the placeholder option
             }

            console.log("Other user dropdown populated."); // Debugging
        }


        function renderUserTabs() {
             console.log("renderUserTabs called"); // Debugging
             const sortedUserNames = Object.keys(data).sort((a, b) => a.localeCompare(b));
             const tabContainer = document.getElementById("userTabs");
             const hideUsersBtn = document.getElementById("hideUsersBtn");
             const toggleArchivedBtn = document.getElementById('toggleArchivedUsersBtn');

             tabContainer.innerHTML = ''; // Clear existing tabs

             if (sortedUserNames.length === 0) {
                  tabContainer.style.display = 'none';
                  if(toggleArchivedBtn) toggleArchivedBtn.style.display = 'none';
                  if(hideUsersBtn) hideUsersBtn.style.display = 'none';
                  console.log("No users, hiding tabs and buttons."); // Debugging
                  // Also ensure other user dropdown is empty/hidden if no users exist
                   populateOtherUserDropdown(); // This will empty it if no users
                   document.getElementById('includeBalanceContainer').style.display = 'none';

                  return;
             } else {
                   // Only set display to 'flex' if it's currently 'none'. Otherwise, leave it as is (flex or user-controlled hidden).
                   if (tabContainer.style.display === 'none' || tabContainer.style.display === "") {
                        tabContainer.style.display = 'flex';
                   }
                  if(hideUsersBtn) hideUsersBtn.style.display = 'inline-block';

                  const hasArchived = Object.values(data).some(user => user.isActive === false);
                  if(toggleArchivedBtn) {
                      toggleArchivedBtn.style.display = hasArchived || showArchivedUsers ? 'inline-block' : 'none';
                  }
                  console.log("Users exist, rendering tabs.", {showArchivedUsers, hasArchived}); // Debugging
                   // Ensure include balance container is visible if users exist and one is selected
                   if (currentUser) document.getElementById('includeBalanceContainer').style.display = 'flex';

             }

             sortedUserNames.forEach(name => {
                  const user = data[name];
                   if (user && (user.isActive !== false || showArchivedUsers)) { // Check user exists and isActive status
                       const btn = document.createElement("button"); btn.textContent = name;
                       btn.onclick = () => selectUser(name); btn.classList.add('user-tab-button');
                       if (user.isActive === false) btn.classList.add('archived');
                       if(name === currentUser) btn.classList.add('active-user-tab');
                       tabContainer.appendChild(btn);
                   }
             });
             applyTranslationsToUI(); // Apply translations to new buttons and potentially update Hide/Show text
             populateOtherUserDropdown(); // Populate the other user dropdown after rendering tabs
             console.log("User tabs rendered."); // Debugging
        }

        function toggleUsers() {
             console.log("toggleUsers called"); // Debugging
            const tabContainer = document.getElementById("userTabs");
             if (Object.keys(data).length === 0) {
                 tabContainer.style.display = 'none';
                 console.log("No users, toggleUsers doing nothing."); // Debugging
                 return;
            }
             tabContainer.style.display = (tabContainer.style.display === "none" || tabContainer.style.display === "") ? "flex" : "none";
             console.log("User tabs display toggled to:", tabContainer.style.display); // Debugging
        }

        function selectUser(name) {
             console.log("selectUser called with:", name); // Debugging
             if (!data[name]) {
                 console.log("User not found:", name, "Resetting state."); // Debugging
                 currentUser = null;
                 currentlyViewedMonth = null;
                 localStorage.removeItem('lastSelectedUser');
                 fullRender(); // Clear display
                 renderUserTabs(); // Ensure tabs are correct
                 populateOtherUserDropdown(); // Update the dropdown
                 return;
             }

             currentUser = name;
             localStorage.setItem('lastSelectedUser', name);
             document.getElementById("selectedUserName").textContent = name;
             document.getElementById("userControl").style.display = "block"; // Show the whole user control block
             document.getElementById('previousBalancePaymentsSection').style.display = 'block'; // Show payments section

             renderUserTabs(); // Update active tab class and re-populate other user dropdown
             populateOtherUserDropdown(); // Ensure dropdown is populated correctly after setting currentUser

             // Set the initial month to view
             let monthToView = currentlyViewedMonth;
             // If no month is currently viewed, or if the current user doesn't have data for the currently viewed month,
             // default to the current system month.
             if (!monthToView || !data[name]?.months?.[monthToView]) {
                monthToView = getCurrentMonth();
                console.log("Setting initial month to view:", monthToView); // Debugging
             } else {
                 console.log("Keeping currently viewed month:", monthToView); // Debugging
             }
             currentlyViewedMonth = monthToView; // Set the global variable


             const rate = Number(data[name]?.rate) || 0;
             document.getElementById("userRate").value = rate === 0 ? '' : rate;

             // Populate overtime rate input
             const overtimeRate = Number(data[name]?.overtimeRate) || 8; // Default to 8 if missing
             document.getElementById("userOvertimeRate").value = overtimeRate === 8 ? '' : overtimeRate; // Display empty if 8


             // Populate manual balance for the selected month
             const monthDataForInput = data[name]?.months?.[currentlyViewedMonth];
             if (monthDataForInput) {
                 const carriedOver = monthDataForInput.carriedOverBalance || 0;
                 document.getElementById("manualCarriedOverBalance").value = Number(carriedOver) === 0 ? '' : Number(carriedOver);
             } else {
                 // If month data doesn't exist yet (e.g., new user, new month)
                 document.getElementById("manualCarriedOverBalance").value = '';
                  // Initialize month data structure if it doesn't exist
                  if (!data[name].months[currentlyViewedMonth]) {
                       data[name].months[currentlyViewedMonth] = { carriedOverBalance: 0, previousBalancePayments: [], days: [] };
                       saveData(); // Save the new month structure
                       console.log(`Initialized data structure for month: ${currentlyViewedMonth}`); // Debugging
                  }
             }

             updateMonthDisplay(); // Update the month display text and button states
             scheduleFullRender(150); // Schedule the rendering of the table and summary

             // Explicitly update archive button visibility and text within data management section if it's open
            const dataManagementButtons = document.getElementById('dataManagementButtons');
            if (dataManagementButtons.style.display === 'flex' || dataManagementButtons.style.display === 'block') {
                const archiveBtn = document.getElementById('archiveUserBtn');
                if (archiveBtn) {
                    if (currentUser && data[currentUser]) { // Re-check if currentUser is still set
                         archiveBtn.style.display = 'inline-block';
                         applyTranslationsToUI(); // Update text and style based on current user
                    } else {
                         archiveBtn.style.display = 'none'; // Hide if user became null
                    }
                } else { console.warn("Archive user button not found."); } // Debugging

                 const toggleArchivedBtn = document.getElementById('toggleArchivedUsersBtn');
                  if (toggleArchivedBtn) {
                    const hasArchived = Object.values(data).some(u => u.isActive === false);
                    toggleArchivedBtn.style.display = hasArchived || showArchivedUsers ? 'inline-block' : 'none';
                 } else { console.warn("Toggle archived users button not found."); } // Debugging
            }
            console.log("User selected:", currentUser); // Debugging
        }

        document.getElementById("userRate").addEventListener("input", (event) => {
            if (currentUser && data[currentUser]) {
                 const rateVal = parseFloat(event.target.value);
                 data[currentUser].rate = !isNaN(rateVal) ? rateVal : 0;
                 saveData();
                 showSummary(activeReportType);
                 // Format the input value back, showing empty for 0
                 event.target.value = data[currentUser].rate === 0 ? '' : data[currentUser].rate;
             }
        });

        // New event listener for Overtime Rate input - ADDED setTimeout WORKAROUND
        document.getElementById("userOvertimeRate").addEventListener("input", (event) => {
            if (currentUser && data[currentUser]) {
                const inputElement = event.target;
                let otRateVal = parseFloat(inputElement.value);
                let valueToSave;

                // Validate: Must be a number and greater than 0
                if (isNaN(otRateVal) || otRateVal <= 0) {
                    valueToSave = 8; // Default to 8 internally
                    console.warn("Invalid overtime rate input or zero/negative, value set to default 8 internally.");
                } else {
                    valueToSave = otRateVal;
                }

                // Call update with the determined value.
                // The update function will save valueToSave and attempt to set inputElement.value based on the saved value.
                update(currentlyViewedMonth, -1, 'overtimeRate', valueToSave, inputElement);

                 // Add a small delay to ensure the input field display is correctly set
                 // This is a common workaround for input type="number" display quirks
                 setTimeout(() => {
                     // After the update (and potential save), check the saved value
                     const savedOtRate = Number(data[currentUser].overtimeRate) || 8;
                     // If the saved value is 8, ensure the input field is empty string
                     if (savedOtRate === 8 && inputElement.value !== '') {
                         inputElement.value = '';
                         console.log("Timeout: Cleared overtime rate input display as saved value is 8.");
                     } else if (savedOtRate !== 8 && parseFloat(inputElement.value) !== savedOtRate) {
                          // If saved value is not 8 and display doesn't match, update display
                         inputElement.value = savedOtRate;
                          console.log("Timeout: Updated overtime rate input display to saved value:", savedOtRate);
                     }
                      // If saved value is 8 and display is already '', or saved value is not 8 and display matches, do nothing.
                 }, 50); // Using a slightly larger delay (50ms) for better reliability
            }
        });


        document.getElementById("manualCarriedOverBalance").addEventListener("change", (event) => {
            if (!currentUser || !currentlyViewedMonth || !data[currentUser]?.months?.[currentlyViewedMonth]) {
                 event.target.value = ''; // Clear input if no valid user/month
                 console.log("Manual balance change ignored: No user or month.", {currentUser, currentlyViewedMonth});
                 return;
             }
              const balanceVal = parseFloat(event.target.value) || 0;
              const monthData = data[currentUser].months[currentlyViewedMonth];

              // Compare floating point numbers safely
              if (Math.abs(Number(balanceVal.toFixed(2)) - Number((monthData.carriedOverBalance || 0).toFixed(2))) > 0.001) {
                   monthData.carriedOverBalance = balanceVal;
                   saveData();
                   showSummary(activeReportType);
                   console.log("Manual balance updated for", {currentUser, currentlyViewedMonth, newBalance: balanceVal}); // Debugging
              } else {
                  console.log("Manual balance value unchanged, no save needed."); // Debugging
              }
               // Format the input value back, showing empty for 0
              event.target.value = Number(monthData.carriedOverBalance) === 0 ? '' : Number(monthData.carriedOverBalance);
        });

        function renderPreviousBalancePayments(monthKey) {
            console.log("renderPreviousBalancePayments called for:", monthKey); // Debugging
            const paymentListDiv = document.getElementById('paymentList');
            paymentListDiv.innerHTML = '';

            const payments = data[currentUser]?.months?.[monthKey]?.previousBalancePayments;

            if (!currentUser || !monthKey || !Array.isArray(payments)) {
                 console.log("No user, month, or payment array found."); // Debugging
                paymentListDiv.innerHTML = `<p>${translate('noPaymentsRecorded')}</p>`;
                return;
            }

            if (payments.length === 0) {
                 console.log("No payments recorded for this month."); // Debugging
                paymentListDiv.innerHTML = `<p>${translate('noPaymentsRecorded')}</p>`;
                return;
            }

            payments.forEach((p, i) => {
                 // Ensure payment object is valid
                 if (!p || typeof p !== 'object' || p.amount === undefined) {
                      console.warn("Skipping invalid payment entry:", p);
                      return; // Skip this entry if it's invalid
                 }
                const entry = document.createElement('div'); entry.className = 'payment-entry';
                const details = document.createElement('span'); details.className = 'payment-details';
                const date = p.date ? new Date(p.date).toLocaleString(currentLanguage === 'hi' ? 'hi-IN' : 'en-GB', {year:'numeric',month:'numeric',day:'numeric',hour:'2-digit',minute:'2-digit'}) : translate('noDate'); // Added date formatting options
                details.textContent = `${translate('amountLabel')} ${(Number(p.amount)||0).toFixed(2)}, ${translate('dateLabel')} ${date}${p.notes ? ` (${p.notes})` : ''}`;

                const btn = document.createElement('button'); btn.className = 'delete-payment-btn'; btn.textContent = '✕';
                btn.onclick = () => deletePreviousBalancePayment(monthKey, i);

                entry.append(details, btn);
                paymentListDiv.appendChild(entry);
            });
             console.log("Payments rendered:", payments.length, "entries."); // Debugging
        }
        function addPreviousBalancePayment() {
             console.log("addPreviousBalancePayment called"); // Debugging
             if (!currentUser || !currentlyViewedMonth || !data[currentUser]?.months?.[currentlyViewedMonth]) {
                 alert(translate('alertSelectUserMonth'));
                 console.log("Add payment failed: No user or month."); // Debugging
                 return;
             }
            const amountInput = document.getElementById('paymentAmount');
            const notesInput = document.getElementById('paymentNotes');
            const amount = parseFloat(amountInput.value);

            if (isNaN(amount) || amount <= 0) {
                 alert(translate('alertEnterValidAmount'));
                 console.log("Add payment failed: Invalid amount:", amount); // Debugging
                 return;
             }
            const notes = notesInput.value.trim();
            const monthData = data[currentUser].months[currentlyViewedMonth];

            // Ensure previousBalancePayments is an array
            if(!Array.isArray(monthData.previousBalancePayments)) {
                 monthData.previousBalancePayments = [];
                 console.warn("previousBalancePayments was not an array, initialized."); // Debugging
            }

            monthData.previousBalancePayments.push({ amount, date: new Date().toISOString(), notes });
            saveData();
            renderPreviousBalancePayments(currentlyViewedMonth);

            amountInput.value = '';
            notesInput.value = '';

            alert(translate('alertPaymentAdded'));
            showSummary(activeReportType); // Update summary after adding payment
            console.log("Payment added:", {amount, notes}); // Debugging
        }
        function deletePreviousBalancePayment(monthKey, index) {
             console.log("deletePreviousBalancePayment called for:", {monthKey, index}); // Debugging
            const payments = data[currentUser]?.months?.[monthKey]?.previousBalancePayments;
            if (!payments || !payments[index]) {
                 console.log("Delete payment failed: Payment not found."); // Debugging
                 return; // Payment not found
            }
            const payment = payments[index];
            if (confirm(translate('confirmDeletePayment', {amount: (Number(payment.amount)||0).toFixed(2)}))) {
                payments.splice(index, 1);
                saveData();
                renderPreviousBalancePayments(monthKey);
                alert(translate('alertPaymentDeleted'));
                showSummary(activeReportType); // Update summary after deleting payment
                 console.log("Payment deleted:", payment); // Debugging
            } else {
                console.log("Delete payment cancelled by user."); // Debugging
            }
        }

        function updateMonthDisplay() {
             console.log("updateMonthDisplay called for:", currentlyViewedMonth); // Debugging
            const monthDisplay = document.getElementById('currentMonthDisplay');
            const prevBtn = document.querySelector('#monthNav button:first-child');
            const nextBtn = document.querySelector('#monthNav button:last-child');
            const quickChangeBtn = document.getElementById('quickMonthChangeBtn');
            const manualBalanceInput = document.getElementById("manualCarriedOverBalance");
            const overtimeRateInput = document.getElementById("userOvertimeRate");


            if (monthDisplay && currentlyViewedMonth) {
                const [year, monthNum] = currentlyViewedMonth.split('-').map(Number);
                 // Use 'long' format for month name
                monthDisplay.textContent = `${new Intl.DateTimeFormat(currentLanguage === 'hi' ? 'hi-IN' : 'en-US', { month: 'long' }).format(new Date(year, monthNum - 1, 1))} ${year}`;

                if (currentUser && data[currentUser]?.months) {
                    const months = Object.keys(data[currentUser].months).sort();
                    // Disable previous if current month is the earliest month with data OR earlier than the earliest month with data
                    prevBtn.disabled = months.length > 0 && (currentlyViewedMonth <= months[0]);
                    // Disable next if current month is the current system month
                    nextBtn.disabled = currentlyViewedMonth === getCurrentMonth();

                    if(quickChangeBtn) quickChangeBtn.style.display = 'inline-block'; // Ensure quick change is visible if month is

                    // Update manual balance input value
                    const monthData = data[currentUser].months[currentlyViewedMonth];
                     if (manualBalanceInput) {
                         manualBalanceInput.value = monthData && Number(monthData.carriedOverBalance) !== 0 ? Number(monthData.carriedOverBalance) : '';
                     }
                     // Update overtime rate input value (only if user is selected)
                     if (overtimeRateInput && currentUser && data[currentUser]) {
                         const overtimeRate = Number(data[currentUser].overtimeRate) || 8;
                         overtimeRateInput.value = overtimeRate === 8 ? '' : overtimeRate; // Display empty if 8
                     }


                } else {
                    // If no user or no months data, disable navigation and clear inputs
                    [prevBtn, nextBtn].forEach(b=>b.disabled=true);
                    if(quickChangeBtn) quickChangeBtn.style.display='none';
                    if(manualBalanceInput) manualBalanceInput.value='';
                    if(overtimeRateInput) overtimeRateInput.value = ''; // Clear overtime rate
                }
                 console.log("Month display updated."); // Debugging
            } else if (monthDisplay) {
                // If no month selected, clear display and disable buttons
                monthDisplay.textContent = '';
                [prevBtn, nextBtn].forEach(b=>b.disabled=true);
                if(quickChangeBtn) quickChangeBtn.style.display='none';
                if(manualBalanceInput) manualBalanceInput.value='';
                if(overtimeRateInput) overtimeRateInput.value = ''; // Clear overtime rate

                 console.log("No month selected, clearing month display."); // Debugging
            }
             checkReminders(); // Update reminders based on potentially new month view
        }

        function getRelativeMonthKey(monthKey, offset) {
            if(!monthKey) return null;
            const [y, m] = monthKey.split('-').map(Number);
            // Create a date object for the 1st day of the given monthKey
            const date = new Date(y, m - 1, 1);
            // Add the offset to the month
            date.setMonth(date.getMonth() + offset);
            // Return the new year and month in CIRCA-MM format
            return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}`;
        }

        function goToPreviousMonth() {
             console.log("goToPreviousMonth called"); // Debugging
             if(currentUser && currentlyViewedMonth){
                 const prevKey = getRelativeMonthKey(currentlyViewedMonth, -1);
                  // Prevent going to a month before the earliest month with data for this user
                  const monthsWithData = Object.keys(data[currentUser].months || {}).sort();
                 if (monthsWithData.length > 0 && prevKey < monthsWithData[0]) {
                      console.log("Prevented navigation before earliest month:", monthsWithData[0]); // Debugging
                      return;
                 }
                 currentlyViewedMonth = prevKey;
                 updateMonthDisplay();
                 scheduleFullRender(50);
                 console.log("Navigated to previous month:", currentlyViewedMonth); // Debugging
             }
        }
        function goToNextMonth() {
             console.log("goToNextMonth called"); // Debugging
             if(currentUser && currentlyViewedMonth){
                 const nextKey = getRelativeMonthKey(currentlyViewedMonth, 1);
                 // Prevent going to a month beyond the current system month
                 if(nextKey > getCurrentMonth()) {
                      console.log("Prevented navigation beyond current system month:", getCurrentMonth()); // Debugging
                      return;
                 }
                 currentlyViewedMonth = nextKey;
                 updateMonthDisplay();
                 scheduleFullRender(50);
                 console.log("Navigated to next month:", currentlyViewedMonth); // Debugging
             }
        }

        function promptQuickMonthChange() {
             console.log("promptQuickMonthChange called"); // Debugging
             if(!currentUser){alert(translate('pleaseSelectUser')); return;}
             const monthInput = prompt(translate('promptMonthInput'),currentlyViewedMonth||getCurrentMonth());

             if(!monthInput) return; // User cancelled prompt

             const trimmedInput = monthInput.trim();
             if (!/^\d{4}-\d{2}$/.test(trimmedInput)){
                 alert(translate('alertInvalidMonthFormat'));
                 console.log("Invalid month format entered:", trimmedInput); // Debugging
                 return;
             }

             const [year, monthNum] = trimmedInput.split('-').map(Number);
             if(year < 1900 || year > 2100 || monthNum < 1 || monthNum > 12){ // Basic year/month validation
                 alert(translate('alertInvalidMonthFormat'));
                 console.log("Invalid year/month value entered:", trimmedInput); // Debugging
                 return;
             }

             const newMonthKey = `${year}-${monthNum.toString().padStart(2, '0')}`;

             // Prevent navigating to a future month relative to the current system date
             if(newMonthKey > getCurrentMonth()){
                 alert(translate('cannotGoToFutureMonth'));
                 console.log("Prevented navigation to future month:", newMonthKey); // Debugging
                 return;
             }

             currentlyViewedMonth = newMonthKey;
             updateMonthDisplay();
             scheduleFullRender(50);
             console.log("Quick changed month to:", currentlyViewedMonth); // Debugging
        }


        function calculateFullMonthTotals(userName, monthKey) {
             console.log("calculateFullMonthTotals called for:", {userName, monthKey}); // Debugging
            const userData = data[userName];
            // Ensure paths exist and are valid arrays/objects before accessing
            if (!userData?.months?.[monthKey] || !Array.isArray(userData.months[monthKey].days)) {
                 console.warn("calculateFullMonthTotals: No or invalid data for monthKey", monthKey); // Debugging
                 // Return 0 for all totals if data is invalid/missing
                 return { totalPresent:0, totalOvertimeHours:0, totalRent:0, totalFood:0, totalDailyReceived:0, grossTotal:0 };
            }

            const daysData = userData.months[monthKey].days;
            let p=0, ot=0, r=0, f=0, rec=0;

            daysData.forEach(d => {
                if(d && typeof d === 'object'){
                    const s = (d.status||'').toUpperCase();
                    if(s==='P')p+=1;
                    else if(s==='H')p+=0.5;
                    ot+=Number(d.overtime)||0;
                    r+=Number(d.rent)||0;
                    f+=Number(d.food)||0;
                    rec+=Number(d.received)||0;
                } else {
                     console.warn("Skipping invalid day entry in calculateFullMonthTotals:", d); // Debugging invalid day objects
                }
            });

            const rate = Number(userData.rate)||0;
            // Use the user's configured overtime rate, default to 8 if missing/invalid
            const otRate = Number(userData.overtimeRate) || 8;

            const hazri = p * rate;
            const otAmount = (rate > 0 && otRate > 0) ? (ot * rate) / otRate : 0; // Check otRate > 0 to prevent division by zero

            const gross = hazri + otAmount + r + f;

            console.log("Calculated totals:", {totalPresent:p, totalOvertimeHours:ot, totalRent:r, totalFood:f, totalDailyReceived:rec, grossTotal:gross}); // Debugging

            return {
                totalPresent: parseFloat(p.toFixed(1)),
                totalOvertimeHours: parseFloat(ot.toFixed(2)),
                totalRent: parseFloat(r.toFixed(2)),
                totalFood: parseFloat(f.toFixed(2)),
                totalDailyReceived: parseFloat(rec.toFixed(2)),
                grossTotal: parseFloat(gross.toFixed(2)),
                // balanceDue is calculated in showSummary or calculateFinalBalance
            };
        }

        // New function to calculate totals for a specific period (slice of days) - Kept for potential future use or debugging period calculations, but not used for included user's FINAL balance
        function calculatePeriodTotals(userName, monthKey, startDayIndex, endDayIndex) {
             console.log("calculatePeriodTotals called for:", {userName, monthKey, startDayIndex, endDayIndex}); // Debugging
            const userData = data[userName];
             if (!userData?.months?.[monthKey] || !Array.isArray(userData.months[monthKey].days)) {
                 console.warn("calculatePeriodTotals: No or invalid data for monthKey", monthKey); // Debugging
                 return { totalPresent:0, totalOvertimeHours:0, totalRent:0, totalFood:0, totalDailyReceived:0, periodGross:0, periodNet:0 };
            }

            // Ensure indices are within bounds
             const safeStart = Math.max(0, startDayIndex);
             const safeEnd = Math.min(userData.months[monthKey].days.length, endDayIndex);

            const daysData = userData.months[monthKey].days.slice(safeStart, safeEnd); // Slice the relevant days

            let p=0, ot=0, r=0, f=0, rec=0;
            daysData.forEach(d => {
                 if(d && typeof d === 'object'){
                    const s=(d.status||'').toUpperCase();
                    if(s==='P')p+=1;
                    else if(s==='H')p+=0.5;
                    ot+=Number(d.overtime)||0;
                    r+=Number(d.rent)||0;
                    f+=Number(d.food)||0;
                    rec+=Number(d.received)||0;
                } else {
                     console.warn("Skipping invalid day entry in calculatePeriodTotals:", d); // Debugging
                }
            });

            const rate = Number(userData.rate)||0;
             // Use the user's configured overtime rate, default to 8 if missing/invalid
            const otRate = Number(userData.overtimeRate) || 8;

            const hazri = p * rate;
            const otAmount = (rate > 0 && otRate > 0) ? (ot * rate) / otRate : 0; // Check otRate > 0

            const periodGross = hazri + otAmount + r + f;
            const periodNet = periodGross - rec;


            console.log("Calculated period totals:", {totalPresent:p, totalOvertimeHours:ot, totalRent:r, totalFood:f, totalDailyReceived:rec, periodGross:periodGross.toFixed(2), periodNet:periodNet.toFixed(2)}); // Debugging

            return {
                 totalPresent: parseFloat(p.toFixed(1)),
                totalOvertimeHours: parseFloat(ot.toFixed(2)),
                totalRent: parseFloat(r.toFixed(2)),
                totalFood: parseFloat(f.toFixed(2)),
                totalDailyReceived: parseFloat(rec.toFixed(2)),
                periodGross: parseFloat(periodGross.toFixed(2)),
                periodNet: parseFloat(periodNet.toFixed(2))
            };
        }


        function getCurrentDateString() {
            const n = new Date();
            const day = n.getDate();
            const month = n.getMonth() + 1; // getMonth() is 0-indexed
            const year = n.getFullYear();
            return `${day}/${month}/${year}`; // Format DD/M/YYYY
        }

        function getDaysInMonth(year, monthIndex) {
            // monthIndex is 0-indexed (0 for January, 11 for December)
            return new Date(year, monthIndex + 1, 0).getDate();
        }

        function calculateFinalBalance(userName, monthKey) {
             console.log("calculateFinalBalance (full month) called for:", {userName, monthKey}); // Debugging
             const userData = data[userName];
             if (!userData?.months?.[monthKey]) {
                 console.warn("calculateFinalBalance: No data for monthKey", monthKey, "Returning 0 balance."); // Debugging
                 return 0;
             }

            const monthData = userData.months[monthKey];
            // Ensure days array exists, though calculateFullMonthTotals already checks this
             if(!Array.isArray(monthData.days)) {
                  console.warn("calculateFinalBalance: Days array missing for monthKey", monthKey, "Treating days calculations as 0."); // Debugging
                  // The calculateFullMonthTotals will handle this gracefully by returning 0s if days is not an array
             }

            const totals = calculateFullMonthTotals(userName, monthKey); // Use full month totals here

            let prevPayments = 0;
            if(Array.isArray(monthData.previousBalancePayments)) {
                 prevPayments = monthData.previousBalancePayments.reduce((sum, payment)=>{
                      // Ensure payment object is valid before summing
                      if(payment && typeof payment === 'object' && payment.amount !== undefined) {
                           return sum + (Number(payment.amount)||0);
                      } else {
                           console.warn("Skipping invalid payment entry in calculateFinalBalance:", payment); // Debugging
                           return sum;
                      }
                 }, 0);
            } else {
                 console.warn("calculateFinalBalance: previousBalancePayments not an array, treating as 0."); // Debugging
            }

            const carried = Number(monthData.carriedOverBalance)||0;

            const finalBalance = parseFloat((totals.grossTotal + carried - totals.totalDailyReceived - prevPayments).toFixed(2));
            console.log("Calculated full month final balance:", finalBalance); // Debugging
            return finalBalance;
        }

        function renderTable(monthKey = currentlyViewedMonth) {
            console.log("renderTable called for:", monthKey); // Debugging
            const container = document.getElementById("tableContainer");
             if (!currentUser || !monthKey) {
                 container.innerHTML = "";
                 console.log("renderTable: No user or month, clearing container."); // Debugging
                 return;
             }

             const userData = data[currentUser];
             if (!userData) {
                 container.innerHTML = "";
                 console.log("renderTable: User data not found for", currentUser, "clearing container."); // Debugging
                 return;
             }

             const [year, monthIndexBase1] = monthKey.split('-').map(Number);
             if (isNaN(year) || year < 1900 || isNaN(monthIndexBase1) || monthIndexBase1 < 1 || monthIndexBase1 > 12) {
                 container.innerHTML = `<p>${translate('errorInvalidMonthKey', { monthKey: monthKey })}</p>`;
                 console.error("renderTable: Invalid month key format or value:", monthKey); // Debugging
                 return;
             }
             const daysInMonth = getDaysInMonth(year, monthIndexBase1 - 1);

              // Ensure month data and days array exist and have correct structure/length
              if (!userData.months[monthKey] || typeof userData.months[monthKey] !== 'object') {
                   userData.months[monthKey] = { carriedOverBalance: 0, previousBalancePayments: [], days: [] };
                   console.log("Initialized month data structure for", monthKey); // Debugging
                   // Save will happen after days array is potentially resized
              }

              let daysData = userData.months[monthKey].days;
               let structureChanged = false;

                // Ensure daysData is an array and has the correct number of days
                if (!Array.isArray(daysData) || daysData.length !== daysInMonth) {
                    console.log(`Resizing/Initializing days array for ${monthKey}. Current length: ${Array.isArray(daysData) ? daysData.length : 'not an array'}, Required length: ${daysInMonth}`); // Debugging
                   const newDays = Array.from({ length: daysInMonth }, (_, i) => {
                        const existingDay = (Array.isArray(daysData) && daysData.length > i) ? daysData[i] : undefined;

                         // Create new day object, migrating existing data if available and valid
                        return (existingDay && typeof existingDay === 'object') ? {
                            date: existingDay.date || `${i+1}/${monthIndexBase1}/${year}`, // Use existing date or generate
                            status: existingDay.status || '',
                            overtime: Number(existingDay.overtime) || 0,
                            rent: Number(existingDay.rent) || 0,
                            food: Number(existingDay.food) || 0,
                            received: Number(existingDay.received) || 0,
                            notes: existingDay.notes || '',
                            updated: existingDay.updated || ''
                        } : { // Create a default empty day object
                             date: `${i+1}/${monthIndexBase1}/${year}`,
                             status:'',
                             overtime:0,
                             rent:0,
                             food:0,
                             received:0,
                             notes:'',
                             updated:''
                         };
                   });
                   userData.months[monthKey].days = newDays;
                   daysData = newDays; // Update the reference
                   structureChanged = true;
                } else {
                    // Ensure existing days are objects and migrate if necessary (e.g., remove location, add missing fields)
                     let dayMigrationNeeded = false;
                     daysData = daysData.map((d, i) => {
                          if (!d || typeof d !== 'object') {
                              dayMigrationNeeded = true;
                              return { date: `${i+1}/${monthIndexBase1}/${year}`, status:'', overtime:0, rent:0, food:0, received:0, notes:'', updated:'' };
                          }
                           // Check for missing fields and add defaults
                           let updatedDay = {...d}; // Create a copy
                           if (updatedDay.date === undefined) { updatedDay.date = `${i+1}/${monthIndexBase1}/${year}`; dayMigrationNeeded = true; }
                           if (updatedDay.status === undefined) { updatedDay.status = ''; dayMigrationNeeded = true; }
                           if (updatedDay.overtime === undefined) { updatedDay.overtime = 0; dayMigrationNeeded = true; }
                           if (updatedDay.rent === undefined) { updatedDay.rent = 0; dayMigrationNeeded = true; }
                           if (updatedDay.food === undefined) { updatedDay.food = 0; dayMigrationNeeded = true; }
                           if (updatedDay.received === undefined) { updatedDay.received = 0; dayMigrationNeeded = true; }
                           if (updatedDay.notes === undefined) { updatedDay.notes = ''; dayMigrationNeeded = true; }
                           if (updatedDay.updated === undefined) { updatedDay.updated = ''; dayMigrationNeeded = true; }
                            if (updatedDay.location !== undefined) { delete updatedDay.location; dayMigrationNeeded = true; } // Remove location field
                           return updatedDay;
                     });
                      if (dayMigrationNeeded) { userData.months[monthKey].days = daysData; structureChanged = true; console.log("Migrated individual day structures for", monthKey); } // Debugging
                }

                // Ensure other month-level properties exist
                if (typeof userData.months[monthKey].carriedOverBalance !== 'number') { userData.months[monthKey].carriedOverBalance = 0; structureChanged = true; }
                 if (!Array.isArray(userData.months[monthKey].previousBalancePayments)) { userData.months[monthKey].previousBalancePayments = []; structureChanged = true; }


                if (structureChanged) {
                    saveData(); // Save any structural changes/migrations
                    console.log("Month data structure updated and saved for", monthKey); // Debugging
                }

              const todayDateString = getCurrentDateString();
              let html = `<div class="table-responsive"><table><thead><tr>
                          <th>${translate('dateHeaderTbl')}</th><th>${translate('statusHeaderTbl')}</th>
                          <th>${translate('otHeaderTbl')}</th><th>${translate('rentHeaderTbl')}</th>
                          <th>${translate('foodHeaderTbl')}</th><th>${translate('receivedHeaderTbl')}</th>
                          <th>${translate('notesHeaderTbl')}</th><th>${translate('editedHeaderTbl')}</th>
                          </tr></thead><tbody>`;

             daysData.forEach((day, i) => {
                  // Ensure day object is valid before rendering
                  if (!day || typeof day !== 'object') {
                       console.warn("Skipping rendering for invalid day object at index", i, day); // Debugging
                       return;
                  }
                  const currentDay = day;
                  // Format date string consistently for comparison
                  const dayDateParts = (currentDay.date || '').split('/').map(Number);
                   // Check if parts are valid numbers and form a valid date
                   const dayDateObj = (dayDateParts.length === 3 && !isNaN(dayDateParts[0]) && !isNaN(dayDateParts[1]) && !isNaN(dayDateParts[2]))
                                       ? new Date(dayDateParts[2], dayDateParts[1] - 1, dayDateParts[0])
                                       : null;
                  const formattedDayDateString = dayDateObj ? `${dayDateObj.getDate()}/${dayDateObj.getMonth()+1}/${dayDateObj.getFullYear()}` : '';


                  const isCurrentDayRow = formattedDayDateString === todayDateString;
                  const rowClass = isCurrentDayRow ? 'current-day-row' : '';

                  const overtimeValue = currentDay.overtime == 0 ? '' : currentDay.overtime;
                  const rentValue = currentDay.rent == 0 ? '' : currentDay.rent;
                  const foodValue = currentDay.food == 0 ? '' : currentDay.food;
                  const receivedValue = currentDay.received == 0 ? '' : currentDay.received;

                  const formattedEdited = currentDay.updated ? new Date(currentDay.updated).toLocaleString(currentLanguage==='hi'?'hi-IN':'en-GB', {year:'numeric',month:'numeric',day:'numeric',hour:'2-digit',minute:'2-digit'}) : "-"; // Added date formatting

                  const rentTdClass = `rent-cell ${rentValue !== '' ? 'input-has-value' : ''}`;
                  const foodTdClass = `food-cell ${foodValue !== '' ? 'input-has-value' : ''}`;
                  const receivedTdClass = `received-cell ${receivedValue !== '' ? 'input-has-value' : ''}`;

                  html += `<tr class="${rowClass}">
                       <td>${currentDay.date || '-'}</td> <td><input type="text" data-month="${monthKey}" data-index="${i}" data-field="status" value="${currentDay.status || ''}" maxlength="1"></td>
                       <td><input type="number" data-month="${monthKey}" data-index="${i}" data-field="overtime" value="${overtimeValue}" min="0"></td>
                       <td class="${rentTdClass}"><input type="number" data-month="${monthKey}" data-index="${i}" data-field="rent" value="${rentValue}" min="0"></td>
                       <td class="${foodTdClass}"><input type="number" data-month="${monthKey}" data-index="${i}" data-field="food" value="${foodValue}" min="0"></td>
                       <td class="${receivedTdClass}"><input type="number" data-month="${monthKey}" data-index="${i}" data-field="received" value="${receivedValue}" min="0"></td>
                       <td><input type="text" data-month="${monthKey}" data-index="${i}" data-field="notes" value="${currentDay.notes || ''}" placeholder="${translate('notesPlaceholder')}"></td>
                       <td id="edited-${monthKey}-${i}">${formattedEdited}</td>
                   </tr>`;
             });
             html += `</tbody></table></div>`;
             container.innerHTML = html;
             addTableEventListeners();
             renderPreviousBalancePayments(monthKey); // Render payments for the current month

             // Re-populate manual balance input value after rendering the table
             const manualBalanceInput = document.getElementById("manualCarriedOverBalance");
             if (manualBalanceInput && currentUser && monthKey && data[currentUser]?.months?.[monthKey]) {
                 const monthData = data[currentUser].months[monthKey];
                 manualBalanceInput.value = Number(monthData.carriedOverBalance) === 0 ? '' : Number(monthData.carriedOverBalance);
             } else if (manualBalanceInput) {
                 manualBalanceInput.value = '';
             }

              // Re-populate overtime rate input value after rendering the table
             const overtimeRateInput = document.getElementById("userOvertimeRate");
             if (overtimeRateInput && currentUser && data[currentUser]) {
                 const overtimeRate = Number(data[currentUser].overtimeRate) || 8;
                 overtimeRateInput.value = overtimeRate === 8 ? '' : overtimeRate;
             } else if (overtimeRateInput) {
                 overtimeRateInput.value = '';
             }


             // Manually trigger class update for placeholder icons after rendering
             container.querySelectorAll('td.rent-cell input, td.food-cell input, td.received-cell input').forEach(input => {
                const td = input.parentElement;
                if (input.value.trim() !== '') td.classList.add('input-has-value'); else td.classList.remove('input-has-value');
             });
             console.log("Table rendered for", monthKey); // Debugging
        }

        function addTableEventListeners() {
            console.log("addTableEventListeners called"); // Debugging
            const table = document.querySelector('#tableContainer table');
              if (!table) {
                   console.log("No table found to attach event listeners."); // Debugging
                   return;
              }
              table.removeEventListener('input', handleTableInput); // Prevent duplicate listeners
              table.addEventListener('input', handleTableInput);
              console.log("Table event listeners attached."); // Debugging
        }

        function handleTableInput(event) {
             // console.log("handleTableInput called", event.target); // Debugging - can be noisy
             const target = event.target;
             // Ensure the target is an input and is inside a table cell with data attributes
             if (target.tagName === 'INPUT' && target.dataset.field && target.parentElement.tagName === 'TD') {
                 const { month, index, field } = target.dataset;
                 let value;

                 // Handle placeholder icon class toggle for specific fields
                 if (['rent', 'food', 'received'].includes(field)) {
                     const td = target.parentElement;
                     if (target.value.trim() !== '') td.classList.add('input-has-value'); else td.classList.remove('input-has-value');
                 }

                 if (field === 'status') {
                      value = target.value.trim().toUpperCase();
                      // Only allow P, H, A, L, or empty string
                      if (!['P', 'H', 'A', 'L', ''].includes(value)) {
                           console.warn(`Invalid status input: "${target.value}". Resetting to empty.`);
                           value = ''; // Reset value if invalid
                           target.value = value; // Update input display immediately
                      }
                 } else if (['overtime', 'rent', 'food', 'received'].includes(field)) {
                      const trimmedValue = target.value.trim();
                      if (trimmedValue === '') {
                           value = 0; // Internal value is 0 for empty input
                      } else {
                           value = parseFloat(trimmedValue);
                           if (isNaN(value)) {
                                console.warn(`Invalid number input for ${field}: "${trimmedValue}". Setting to 0.`);
                                value = 0; // Treat invalid numbers as 0 internally
                                // Do NOT update target.value here, let the update function handle display based on saved data
                           }
                           // Optional: Restrict negative input directly in the field if min="0" is not strictly enforced
                            if (value < 0) {
                                console.warn(`Negative number input for ${field}: ${value}. Setting to 0.`);
                                value = 0; // Treat negative numbers as 0 internally
                                // Do NOT update target.value here
                            }
                      }
                      // Ensure the input displays as empty if the intended internal value is 0
                       // This is handled inside update, but ensuring the value passed is 0 is key.
                 } else if (field === 'notes') {
                     value = target.value.trim();
                 } else {
                     console.log("Unhandled field:", field); // Debugging
                     return; // Ignore other fields
                 }

                 // Call update with the determined internal value
                 update(month, parseInt(index), field, value, target);
             } else {
                 // console.log("Input event ignored, not a data field input in a TD.", target); // Debugging - can be noisy
             }
        }


        function update(month, i, field, value, inputElement) {
            console.log("update called for:", {month, i, field, value}); // Debugging

            // Handle user-level properties like rate and overtimeRate
            if (i === -1 && currentUser && data[currentUser]) {
                 const user = data[currentUser];
                 let currentValue;
                 let valueChanged = false;

                 if (field === 'overtimeRate') {
                      currentValue = user.overtimeRate || 8;
                      // Compare against default 8 if missing/invalid
                      valueChanged = Math.abs((value || 8) - (currentValue || 8)) > 0.001;
                      if (valueChanged) {
                           user.overtimeRate = value;
                      }
                 } else if (field === 'rate') {
                      currentValue = user.rate || 0;
                      valueChanged = Math.abs((value || 0) - (currentValue || 0)) > 0.001;
                       if (valueChanged) {
                           user.rate = value;
                       }
                 } else {
                     console.warn(`Unhandled user-level update for field: ${field}`);
                     return; // Ignore other user-level fields for now
                 }


                 if (valueChanged) {
                      saveData();
                      showSummary(activeReportType);
                      console.log(`User-level property ${field} updated for ${currentUser}:`, value); // Debugging
                 } else {
                      console.log(`User-level property ${field} unchanged for ${currentUser}.`); // Debugging
                 }
                  // Ensure input element reflects the saved value (empty for 8 for otRate, empty for 0 for rate)
                 if (inputElement) {
                      if (field === 'overtimeRate') {
                           const savedOtRate = Number(user.overtimeRate) || 8;
                           inputElement.value = savedOtRate === 8 ? '' : savedOtRate;
                      } else if (field === 'rate') {
                            const savedRate = Number(user.rate) || 0;
                            inputElement.value = savedRate === 0 ? '' : savedRate;
                      }
                 }
                 return; // Exit if it was a user-level update
            }


            // Check if user, month data, and day data exist for day-level updates
            if (!currentUser || !data[currentUser]?.months?.[month]?.days?.[i]) {
                    console.warn("Update failed: Data path invalid for", {currentUser, month, i}); // Debugging
                   // Revert input element value if data structure is invalid
                   // This might need more robust handling depending on how invalid state is reached
                   if(inputElement) {
                       // Attempt to revert to a default or empty state if data is truly broken
                       const defaultValue = (typeof value === 'number' || field === 'status') ? '' : (typeof value === 'string' ? '' : '-');
                        inputElement.value = defaultValue;
                   }
                   return;
              }

              const day = data[currentUser].months[month].days[i];
              const currentValue = day[field];
              let valueChanged = false;

              // Compare values based on type
              if (typeof value === 'number') {
                   // Compare numbers. Handle 0 and empty string/null/undefined as equivalent for change detection.
                   const numericCurrentValue = Number(currentValue) || 0; // Treat non-numbers/empty as 0
                   const numericValue = value || 0; // Treat null/undefined/falsey value as 0

                   // Check if the numeric values are meaningfully different
                   valueChanged = Math.abs(numericValue - numericCurrentValue) > 0.001;

                    // Special case: If both are numerically 0, but one is '' and the other is 0,
                    // we still consider it changed if the *type* or *exact value* is different
                    // (e.g., changing from '' to 0 should save 0 explicitly).
                    // However, the current requirement is that 0 and '' are functionally the same
                    // for *display* and *storage* (0 is stored, '' is displayed).
                    // Let's stick to the numeric comparison for `valueChanged`. The display handling
                    // after save will manage the '' vs 0 in the input box.


              } else if (typeof value === 'string') {
                   // Compare strings, trimming whitespace
                   valueChanged = value.trim() !== (currentValue || '').trim();
              } else {
                    // Handle cases where types might differ unexpectedly
                    console.warn(`Type mismatch during update comparison for field ${field}. Value type: ${typeof value}, Current value type: ${typeof currentValue}`);
                    valueChanged = value !== currentValue; // Fallback comparison
              }


              // Only update if the value has actually changed and the field exists on the day object
              if (valueChanged && Object.prototype.hasOwnProperty.call(day, field)) {
                  day[field] = value; // Save the new value (0 if number input was empty)
                  console.log(`Value changed for ${field} at index ${i} in month ${month}:`, value); // Debugging

                  // Update timestamp only if a meaningful field changed (not 'updated' itself)
                  if (field !== 'updated') {
                      day.updated = new Date().toISOString();
                      const editedCell = document.getElementById(`edited-${month}-${i}`);
                       // Update the displayed "Edited" timestamp with formatting
                      if(editedCell) editedCell.textContent = new Date(day.updated).toLocaleString(currentLanguage==='hi'?'hi-IN':'en-GB', {year:'numeric',month:'numeric',day:'numeric',hour:'2-digit',minute:'2-digit'});
                      console.log("Updated timestamp for day:", day.updated); // Debugging
                  }
                  saveData();
                  showSummary(activeReportType); // Update summary after saving data
              } else {
                  // Value unchanged based on comparison. If it's a number field and the input was cleared
                  // but the saved value was already 0, the input needs to be set to '' for display.
                  // The display handling below takes care of this regardless of valueChanged.
                   console.log(`Value unchanged for ${field} at index ${i} in month ${month}, not saving.`, {field, value, currentValue, valueChanged}); // Debugging
              }

               // Ensure input element reflects the SAVED value after update attempt
               if (inputElement) {
                   const savedValue = day[field]; // Get the value that was actually saved (or not saved)
                   if (['overtime', 'rent', 'food', 'received'].includes(field)) {
                       // For number fields, display empty string if the saved value is 0
                       inputElement.value = (Number(savedValue) || 0) === 0 ? '' : savedValue;
                       // Also manually ensure placeholder icon class is correct after updating input value
                        const td = inputElement.parentElement;
                       if (td) { // Check if parent td exists
                            if (inputElement.value.trim() !== '') td.classList.add('input-has-value'); else td.classList.remove('input-has-value');
                       }

                   } else if (field === 'status' || field === 'notes') {
                       // For text fields, display the saved value (or empty string if null/undefined)
                       inputElement.value = savedValue || '';
                   }
               }
        }


        function showSummary(calcType) {
             console.log("showSummary called with:", calcType); // Debugging
             const summary = document.getElementById("summarySection");
             const otherUserSelect = document.getElementById('otherUserForReport');
             let selectedOtherUser = otherUserSelect ? otherUserSelect.value : '';
             if (selectedOtherUser === '') selectedOtherUser = null; // Treat empty string as no user selected

             // Reset combined balance and other user final balance at the start of summary calculation
             combinedFinalBalanceForReport = 0;
             otherUserFinalBalanceForReport = 0; // Reset

            if (!currentUser || !currentlyViewedMonth || !data[currentUser]?.months?.[currentlyViewedMonth]) { // Check for month data object
                summary.innerHTML = `<p>${translate('alertSelectUserMonth')}</p>`;
                finalBalanceForReport = 0;
                console.log("showSummary: No user or month data, displaying prompt."); // Debugging
                return;
            }

            const userData = data[currentUser];
            const currentMonthKey = currentlyViewedMonth;
            const currentMonthData = userData.months[currentMonthKey];

            // Ensure monthData structure is valid before proceeding
            if (!currentMonthData || typeof currentMonthData !== 'object' || !Array.isArray(currentMonthData.days) || !Array.isArray(currentMonthData.previousBalancePayments)) {
                 console.error("showSummary: Invalid or incomplete month data structure for current user", currentMonthKey, currentMonthData); // Debugging
                 summary.innerHTML = `<p>${translate('noDataForMonth', {monthKey: currentMonthKey})}</p>`;
                 finalBalanceForReport = 0;
                 return;
            }

            const carriedOverBalance = Number(currentMonthData.carriedOverBalance) || 0;
            let daysToReport = [], summaryTitleKey = "", summaryTitleParams = {};
            const [year, monthNum] = currentMonthKey.split('-').map(Number);
             // Use 'long' format for month name
            const monthNameForTitle = new Intl.DateTimeFormat(currentLanguage==='hi'?'hi-IN':'en-US',{month:'long'}).format(new Date(year,monthNum-1,1));
            const actualDays = currentMonthData.days; // Already ensured to be an array above

            let startDayIndex = 0;
            let endDayIndex = actualDays.length; // Full month by default

            if(calcType==='fullMonth'){
                summaryTitleKey='reportTitleFull';
                summaryTitleParams={days:actualDays.length,month:monthNameForTitle,year};
            } else if(calcType==='firstHalfCurrent'){
                endDayIndex=Math.min(15,actualDays.length);
                summaryTitleKey='reportTitleFirstHalf';
                 summaryTitleParams={days:endDayIndex,month:monthNameForTitle,year};
            } else if(calcType==='afterFifteenth'){
                startDayIndex=15;
                endDayIndex=actualDays.length;
                summaryTitleKey='reportTitleAfterFifteenth';
                 summaryTitleParams={days:Math.max(0, actualDays.length - 15),month:monthNameForTitle,year}; // Calculate days after 15th
            } else {
                 console.error("showSummary: Invalid calculation type:", calcType); // Debugging
                 summary.innerHTML=`<p>Error: Invalid report type selected.</p>`;
                 finalBalanceForReport=0; combinedFinalBalanceForReport=0; otherUserFinalBalanceForReport=0; return;
            }

             // Recalculate current user's period totals based on the actual days slice (Still useful for displaying their section)
             const currentUserPeriodTotals = calculatePeriodTotals(currentUser, currentMonthKey, startDayIndex, endDayIndex);
             const p = currentUserPeriodTotals.totalPresent;
             const ot = currentUserPeriodTotals.totalOvertimeHours;
             const r = currentUserPeriodTotals.totalRent;
             const f = currentUserPeriodTotals.totalFood;
             const rec = currentUserPeriodTotals.totalDailyReceived;
             const grossTotal = currentUserPeriodTotals.periodGross;

             // Use the current user's configured rate and overtime rate for their summary lines
             const currentUserRate = Number(userData.rate)||0;
             const currentUserOvertimeRate = Number(userData.overtimeRate) || 8;
             const currentUserHazriTotal = p * currentUserRate;
             const currentUserOtAmount = (currentUserRate > 0 && currentUserOvertimeRate > 0) ? (ot * currentUserRate) / currentUserOvertimeRate : 0;


            let prevBalPayments = 0;
            if(Array.isArray(currentMonthData.previousBalancePayments)) {
                 prevBalPayments = currentMonthData.previousBalancePayments.reduce((sum, payment)=>{
                      // Ensure payment object is valid before summing
                      if(payment && typeof payment === 'object' && payment.amount !== undefined) {
                           return sum + (Number(payment.amount)||0);
                      } else {
                           console.warn("showSummary: Skipping invalid payment entry during calculation:", payment); // Debugging
                           return sum;
                      }
                 }, 0);
            } else {
                 console.warn("showSummary: previousBalancePayments not an array, treating as 0."); // Debugging
            }

            // Calculate the current user's final balance due (includes carried over and all payments)
            finalBalanceForReport = calculateFinalBalance(currentUser, currentMonthKey);


            let summaryHtml = `<h3>${translate('reportFor',{user:currentUser,title:translate(summaryTitleKey,summaryTitleParams)})}</h3>
                <p>${translate('attendanceSummary',{days:p.toFixed(1),rate:currentUserRate.toFixed(2),total:currentUserHazriTotal.toFixed(2)})}</p>
                <p>${translate('overtimeSummary',{hours:ot.toFixed(2),amount:currentUserOtAmount.toFixed(2),hoursPerDay:currentUserOvertimeRate})}</p>
                <p>${translate('rentSummary',{amount:r.toFixed(2)})}</p>
                <p>${translate('foodSummary',{amount:f.toFixed(2)})}</p>
                <p><strong>${translate('currentPeriodGross',{amount:grossTotal.toFixed(2)})}</strong></p>
                <p><strong>${translate('carriedOverBalance',{amount:carriedOverBalance.toFixed(2)})}</strong></p>
                <p><strong>${translate('totalOwed',{amount:(grossTotal + carriedOverBalance).toFixed(2)})}</strong></p><hr style="margin:0.5rem 0">
                <p>${translate('totalReceivedDaily',{amount:rec.toFixed(2)})}</p>
                 <p>${translate('totalReceivedPrevBalance',{amount:prevBalPayments.toFixed(2)})} ${prevBalPayments===0?`(${translate('noPaymentsRecorded')})`:''}</p>
                <p><strong>${translate('totalAllReceived',{amount:(rec + prevBalPayments).toFixed(2)})}</strong></p><hr style="margin:0.5rem 0">
                `; // Removed the original finalBalanceDue line here


            // Include other user's balance if selected
            if (selectedOtherUser && data[selectedOtherUser] && data[selectedOtherUser].isActive !== false) {
                 console.log("Including balance for other user:", selectedOtherUser); // Debugging
                 const otherUserData = data[selectedOtherUser];
                 const otherUserMonthData = otherUserData?.months?.[currentMonthKey];

                 if (otherUserMonthData && typeof otherUserMonthData === 'object') { // Just need the month object to calculate final balance
                     // Calculate the other user's FULL final balance for the same month
                     otherUserFinalBalanceForReport = calculateFinalBalance(selectedOtherUser, currentMonthKey);

                     // Display the other user's Final Balance Due
                     summaryHtml += `<hr style="margin:0.5rem 0">
                                    <h4>${translate('includeBalanceOf')} ${selectedOtherUser} (${translate('forUser', {user: ""})})</h4>
                                    <p><strong>${translate('otherUserFinalBalance', {otherUser: selectedOtherUser, amount: otherUserFinalBalanceForReport.toFixed(2)})}</strong></p>`;

                     // Calculate combined final balance by adding other user's FULL final balance to current user's final balance
                     combinedFinalBalanceForReport = parseFloat((finalBalanceForReport + otherUserFinalBalanceForReport).toFixed(2));

                     // Display the combined final balance
                     summaryHtml += `<hr style="margin:0.5rem 0">
                                    <p><strong>${translate('combinedFinalBalance', {currentUser: currentUser, otherUser: selectedOtherUser, amount: combinedFinalBalanceForReport.toFixed(2)})}</strong></p>`;

                 } else {
                      console.warn(`No data or invalid data structure for other user ${selectedOtherUser} for month ${currentMonthKey}. Cannot include their balance.`); // Debugging
                     otherUserFinalBalanceForReport = 0; // Reset if data is invalid
                     combinedFinalBalanceForReport = finalBalanceForReport; // Combined is just the current user's
                     summaryHtml += `<hr style="margin:0.5rem 0"><p><em>Could not load data for ${selectedOtherUser} for this month.</em></p>`; // Add a message
                     // If other user data is invalid, show only the current user's balance line
                      summaryHtml += `<p><strong>${translate('finalBalanceDue',{amount:finalBalanceForReport.toFixed(2)})}</strong></p>`;
                 }
            } else {
                 // No other user selected or invalid other user
                 combinedFinalBalanceForReport = finalBalanceForReport; // Combined is just the current user's
                 otherUserFinalBalanceForReport = 0; // Reset
                 // Display only the current user's final balance
                 summaryHtml += `<p><strong>${translate('finalBalanceDue',{amount:finalBalanceForReport.toFixed(2)})}</strong></p>`;
            }


            summary.innerHTML = summaryHtml;
            activeReportType = calcType;
             console.log("Summary displayed for", calcType, "Final Balance:", finalBalanceForReport, "Included Other User Final Balance:", otherUserFinalBalanceForReport, "Combined Balance:", combinedFinalBalanceForReport); // Debugging
        }

        async function shareReport() {
             console.log("shareReport called"); // Debugging
             const reportArea = document.getElementById('reportArea');
            const summaryDiv = document.getElementById('summarySection');
            const tableContainer = document.getElementById('tableContainer');

            // Check if a valid report exists
            if (!summaryDiv || summaryDiv.innerText.trim()==="" || summaryDiv.innerText.includes(translate('alertSelectUserMonth')) || !tableContainer || tableContainer.innerHTML.trim() === "") {
                 alert(translate('alertGenerateReportFirst'));
                 console.log("Share failed: No report generated."); // Debugging
                 return;
            }
            // Check if essential data is available
            if (!currentUser || !currentlyViewedMonth || !data[currentUser]?.months?.[currentlyViewedMonth]) {
                 alert(translate('alertCannotGenerateImage'));
                 console.log("Share failed: Essential data missing."); // Debugging
                 return;
            }

            // Elements to temporarily hide for the screenshot
            const elementsToHide = [
                document.getElementById('addPaymentForm'),
                document.getElementById('quickMonthChangeBtn'),
                document.getElementById('dataManagementButtons'), // Hide entire data management section
                 // Hide the new quick controls container as its children are handled by flex
                // document.getElementById('userQuickControls'), // This might be redundant if children are hidden individually below

                // Hide the individual inputs/selects within quick controls
                document.getElementById('userRate'),
                document.getElementById('userOvertimeRate'),
                document.getElementById('manualCarriedOverBalance'),
                document.getElementById('otherUserForReport'),

                ...(document.getElementById('previousBalancePaymentsSection')?.querySelectorAll('.delete-payment-btn') || []) // Hide delete buttons
            ].filter(el => el != null); // Filter out null elements if any ID is missing


            // Also hide the labels that were made display: none anyway, just to be safe
            document.querySelectorAll('#userQuickControls label').forEach(label => elementsToHide.push(label));


            const originalDisplays = elementsToHide.map(el => el.style.display);
            elementsToHide.forEach(el => { el.style.display = 'none'; });
            console.log("Elements temporarily hidden for screenshot."); // Debugging


            // Replace input fields with spans for cleaner screenshot (only inputs in the table)
            const inputsToReplace = [];
            document.querySelectorAll('#tableContainer tbody td input').forEach(input => {
                const td = input.parentElement;
                if(!td) return;
                const span = document.createElement('span');
                const field = input.dataset.field;
                let displayValue = input.value;

                // Format display value based on field type
                if(['overtime','rent','food','received'].includes(field)){
                    const num = parseFloat(displayValue);
                    displayValue = (isNaN(num)||num===0)?'':num.toFixed(0); // Use fixed(0) for whole numbers
                } else if(field==='status') {
                    displayValue=displayValue.trim().toUpperCase();
                } else {
                    displayValue=displayValue.trim();
                }

                span.textContent=displayValue;
                const compStyle = window.getComputedStyle(input);

                // Apply styles to the span to mimic the input's appearance
                span.style.cssText = `
                    display: inline-block;
                    width: 100%;
                    box-sizing: border-box;
                    padding: ${compStyle.padding};
                    text-align: ${td.offsetWidth <= 35 ? 'center' : compStyle.textAlign}; /* Center smaller columns */
                    vertical-align: middle;
                    line-height: ${compStyle.lineHeight};
                    font-size: ${compStyle.fontSize};
                    font-family: ${compStyle.fontFamily};
                    color: ${compStyle.color};
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    background-color: transparent;
                    border: none;
                `;
                td.style.verticalAlign='middle';
                inputsToReplace.push({input, parentTd: td, tempSpan: span});
                td.replaceChild(span, input); // Replace input with span
            });
            console.log("Inputs replaced with spans for screenshot."); // Debugging

            // Hide table rows not included in the current report type
            let startDay = 1, endDayVal = getDaysInMonth(...currentlyViewedMonth.split('-').map(Number).map((n,i)=>i===1?n-1:n)); // Days in the month
            if(activeReportType==='firstHalfCurrent') endDayVal = Math.min(15,endDayVal); // First 15 days
            else if(activeReportType==='afterFifteenth') startDay = 16; // After 15th

            const hiddenRows = [];
            document.querySelectorAll('#tableContainer tbody tr').forEach(row => {
                 // Extract day number from the first cell's text content (format DD/M/YYYY)
                 const dateCellText = row.cells[0]?.textContent;
                 if (!dateCellText) return; // Skip if date cell is missing
                 const dayNum = parseInt(dateCellText.split('/')[0]);

                 if(!isNaN(dayNum) && (dayNum < startDay || dayNum > endDayVal)){
                    row.style.display='none';
                    hiddenRows.push(row);
                 }
            });
             console.log("Hidden table rows outside report range:", hiddenRows.length); // Debugging

            // Give the DOM a moment to update after hiding/replacing elements
            await new Promise(r => setTimeout(r, 50));

            // Add footer text before capturing
            const footerDiv = document.getElementById('reportFooter');
            if(footerDiv){
                const now = new Date();
                const formatter = new Intl.DateTimeFormat(currentLanguage==='hi'?'hi-IN-u-nu-latn':'en-GB', {year:'numeric',month:'long',day:'numeric',hour:'2-digit',minute:'2-digit',second:'2-digit'});
                const reportPeriodKey = activeReportType==='firstHalfCurrent'?'reportPeriodFirstHalf':activeReportType==='afterFifteenth'?'reportPeriodPeriodAfter15th':'reportPeriodFullMonth'; // Fixed typo here - was PeriodAfter15th, should be After15th

                let otherUserBalanceString = "";
                let finalBalanceToDisplay = finalBalanceForReport; // Default to current user's balance

                const otherUserSelect = document.getElementById('otherUserForReport');
                const selectedOtherUser = otherUserSelect ? otherUserSelect.value : '';

                 // Check if an other user is selected and their data for the month exists
                if (selectedOtherUser && data[selectedOtherUser] && data[selectedOtherUser].isActive !== false && data[selectedOtherUser]?.months?.[currentlyViewedMonth]) {
                     // Use the globally stored other user's final balance for the footer text
                     // Recalculate here just to be safe, in case showSummary wasn't the last thing called
                     const includedUserFinalBalance = calculateFinalBalance(selectedOtherUser, currentlyViewedMonth);

                     if (includedUserFinalBalance !== 0 || finalBalanceForReport !== 0) { // Only add if combined isn't 0
                          // Use the new translation key for the footer text
                         otherUserBalanceString = translate('footerIncludeOtherUserFinalBalance', {
                             otherUser: selectedOtherUser,
                             otherUserFinalBalance: includedUserFinalBalance.toFixed(2),
                             combinedBalance: (finalBalanceForReport + includedUserFinalBalance).toFixed(2) // Calculate combined here for footer text
                         });
                         // In the main "Final Balance Due" line, show the combined balance
                         finalBalanceToDisplay = finalBalanceForReport + includedUserFinalBalance;
                     }


                } else {
                    // No other user selected or their data is missing/invalid
                    finalBalanceToDisplay = finalBalanceForReport; // Just show the current user's final balance
                     otherUserBalanceString = ""; // Ensure this is empty if no other user included
                }

                 footerDiv.textContent = translate('reportGeneratedOn',{
                     user:currentUser,
                     monthYear:currentlyViewedMonth,
                     period:translate(reportPeriodKey),
                     balance:finalBalanceToDisplay.toFixed(2), // Use combined or current user's balance here
                     dateTime:formatter.format(now),
                     otherUserBalanceString: otherUserBalanceString // Append the other user info if applicable
                 });

                 console.log("Report footer added with text:", footerDiv.textContent); // Debugging
                 await new Promise(r => setTimeout(r, 50)); // Give DOM a moment to update the footer
            }

            // Function to restore the UI elements
            const restoreElements = () => {
                console.log("Restoring hidden elements and inputs."); // Debugging
                elementsToHide.forEach((el, i) => { if(el) el.style.display = originalDisplays[i]; });
                inputsToReplace.forEach(({input, parentTd, tempSpan}) => {
                     if(parentTd && parentTd.contains(tempSpan)) { // Ensure parentTd exists and still contains the span
                         parentTd.replaceChild(input, tempSpan);
                         // Restore original vertical alignment if it was changed
                         parentTd.style.verticalAlign = '';
                     }
                });
                hiddenRows.forEach(row => { row.style.display = ''; }); // Show hidden rows again
                if(footerDiv) footerDiv.textContent = ''; // Clear footer text
                 console.log("UI restoration complete."); // Debugging
            };

            try {
                // Generate canvas from the reportArea element
                const canvas = await html2canvas(reportArea, {
                    scale: 2, // Increase scale for better resolution
                    logging: false, // Disable html2canvas logging
                    useCORS: true, // Allow cross-origin images if any (unlikely here, but good practice)
                    backgroundColor: document.documentElement.classList.contains('dark') ? '#2d3748' : '#ffffff', // Set background color explicitly
                    ignoreElements: el => { // Ignore specific elements during capture
                        return el.classList.contains('delete-payment-btn') ||
                               el.id === 'dataManagementButtons' ||
                               el.id === 'userTabs' || // Ensure user tabs are also ignored
                               el.id === 'controlsHeader' || // Ignore the main header
                               el.classList.contains('control-icon') || // Ignore individual control icons
                               el.closest('#topControls') !== null; // Ignore elements within top controls
                    }
                });

                if(!canvas) {
                    throw new Error("Canvas creation failed.");
                }
                console.log("Canvas created successfully."); // Debugging

                // Convert canvas to PNG blob
                canvas.toBlob(async blob => {
                    restoreElements(); // Restore UI immediately after canvas is generated
                    if(!blob){
                        alert(translate('alertCouldNotGenerateImage'));
                        console.error("Canvas to blob conversion failed."); // Debugging
                        return;
                    }

                    // Create a file object from the blob
                    const file = new File([blob], `attendance_report_${currentUser}_${currentlyViewedMonth}_${activeReportType}.png`, {type:'image/png'});
                    console.log("Blob created, file ready for sharing."); // Debugging

                    // Prepare share data
                    const [yr, mth] = currentlyViewedMonth.split('-').map(Number);
                    const shareTitle = translate('reportFor', {
                        user: currentUser,
                        title: `${new Intl.DateTimeFormat(currentLanguage === 'hi' ? 'hi-IN' : 'en-US', { month: 'long', year: 'numeric' }).format(new Date(yr, mth - 1, 1))}${translate(activeReportType === 'firstHalfCurrent' ? 'reportPeriodFirstHalf' : activeReportType === 'afterFifteenth' ? 'reportPeriodAfter15th' : 'reportPeriodFullMonth')}` // Fixed typo here again - was PeriodAfter15th, should be After15th
                    });

                     // Determine the balance text for sharing (uses the same logic as the main balance display)
                     const otherUserSelect = document.getElementById('otherUserForReport');
                     const selectedOtherUser = otherUserSelect ? otherUserSelect.value : '';
                     let shareBalanceAmount = finalBalanceForReport;
                     // Only include other user's balance if they are selected AND their data for the current month exists AND they are active
                     if (selectedOtherUser && data[selectedOtherUser] && data[selectedOtherUser].isActive !== false && data[selectedOtherUser]?.months?.[currentlyViewedMonth]) {
                           const includedUserFinalBalance = calculateFinalBalance(selectedOtherUser, currentlyViewedMonth);
                           shareBalanceAmount = finalBalanceForReport + includedUserFinalBalance;
                      }


                    const balanceText = (selectedOtherUser && data[selectedOtherUser] && data[selectedOtherUser].isActive !== false && data[selectedOtherUser]?.months?.[currentlyViewedMonth])
                         ? translate('combinedFinalBalance', {currentUser: currentUser, otherUser: selectedOtherUser, amount: shareBalanceAmount.toFixed(2)}) // Use combined key and amount
                         : translate('finalBalanceDue', {amount: finalBalanceForReport.toFixed(2)}); // Use current user key and amount


                    const shareText = `${shareTitle}\n${balanceText}`;

                    // Attempt to use Web Share API if available
                    if(navigator.share && navigator.canShare && navigator.canShare({files:[file]})){
                        try {
                            await navigator.share({
                                files: [file],
                                title: shareTitle,
                                text: shareText
                            });
                            console.log("Web share successful."); // Debugging
                        } catch(err) {
                            if(err.name !== 'AbortError'){
                                alert(translate('alertWebShareFailed'));
                                console.error("Web share failed:", err); // Debugging share error
                                downloadBlob(blob, file.name); // Fallback to download
                            } else {
                                console.log("Web share cancelled by user."); // Debugging user cancellation
                                // alert(translate('alertWebShareCancelled')); // Optional: notify user about cancellation
                            }
                        }
                    } else {
                         console.log("Web Share API not supported, falling back to download."); // Debugging
                        downloadBlob(blob, file.name); // Fallback to download
                        alert(translate('alertImageDownloaded'));
                    }
                }, 'image/png', 0.9); // Quality 0.9
            } catch(err) {
                console.error("Error generating report image:", err); // Debugging capture error
                restoreElements(); // Ensure UI is restored even if capture fails
                alert(`${translate('alertCouldNotGenerateImage')}\nError: ${err.message}`);
            }
        }

        function downloadBlob(blob, filename) {
            console.log("downloadBlob called for:", filename); // Debugging
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a); // Append to body to make it clickable in some browsers
            a.click();
            document.body.removeChild(a); // Clean up
            URL.revokeObjectURL(url); // Free up memory
             console.log("Blob download initiated."); // Debugging
        }

        function getCurrentMonth() {
            const d = new Date();
            const year = d.getFullYear();
            const month = (d.getMonth() + 1).toString().padStart(2, "0"); // getMonth() is 0-indexed
            return `${year}-${month}`;
        }

        // UPDATED toggleDataMenu to handle Archive User Button visibility
        function toggleDataMenu() {
            console.log("toggleDataMenu called"); // Debugging
            const menu = document.getElementById('dataManagementButtons');
            const archiveBtn = document.getElementById('archiveUserBtn');
            const toggleArchivedBtn = document.getElementById('toggleArchivedUsersBtn');

            if (menu.style.display === 'none' || menu.style.display === "") {
                menu.style.display = 'flex'; // Show the menu
                console.log("Data management menu shown."); // Debugging

                // Update and show Archive/Reactivate button if a user is selected
                if (archiveBtn) {
                    if (currentUser && data[currentUser]) {
                         archiveBtn.style.display = 'inline-block';
                         applyTranslationsToUI(); // Update text and style based on current user
                    } else {
                         archiveBtn.style.display = 'none'; // Hide if no user selected
                    }
                } else { console.warn("Archive user button not found."); } // Debugging

                // Update and show Show/Hide Archived button if there are archived users or we are showing them
                if (toggleArchivedBtn) {
                    const hasArchived = Object.values(data).some(u => u.isActive === false);
                    toggleArchivedBtn.style.display = hasArchived || showArchivedUsers ? 'inline-block' : 'none';
                    applyTranslationsToUI(); // Update text (Show/Hide Archived)
                } else { console.warn("Toggle archived users button not found."); } // Debugging
            } else {
                menu.style.display = 'none'; // Hide the menu
                console.log("Data management menu hidden."); // Debugging
                 // The buttons inside will automatically be hidden as their parent is hidden.
            }
        }

        function clearAllData() {
             console.log("clearAllData called"); // Debugging
            if(confirm(translate('confirmClearData'))){
                if(renderTimeout) clearTimeout(renderTimeout);

                localStorage.removeItem('attendanceData');
                localStorage.removeItem('lastSelectedUser');

                data = {}; // Reset data object
                currentUser = null;
                currentlyViewedMonth = null;
                finalBalanceForReport = 0;
                combinedFinalBalanceForReport = 0;
                otherUserFinalBalanceForReport = 0; // Reset new variable
                importDataBuffer = null;
                showArchivedUsers = false;

                // Reset UI state
                fullRender(); // This will hide most sections as currentUser is null
                document.getElementById("newUserName").value = "";
                document.getElementById("userTabs").innerHTML = ""; // Clear tabs manually
                document.getElementById("userTabs").style.display = 'none'; // Hide tab container
                populateOtherUserDropdown(); // Clear other user dropdown

                // Reset mode preferences from local storage or default
                setDarkMode(localStorage.getItem('darkMode') === 'enabled');
                currentLanguage = localStorage.getItem('appLanguage') || 'hi';
                document.documentElement.lang = currentLanguage;

                applyTranslationsToUI(); // Apply translations after resetting language

                saveData(); // Explicitly save empty data

                alert(translate('alertDataCleared'));

                // Hide data management menu after clearing
                const menu = document.getElementById('dataManagementButtons');
                if(menu) menu.style.display = 'none';

                 console.log("All data cleared."); // Debugging
            } else {
                 console.log("Clear data cancelled by user."); // Debugging
            }
        }

        function exportData() {
             console.log("exportData called"); // Debugging
            try{
                 const exportObj = {
                     attendanceData: data,
                     exportDate: new Date().toISOString(),
                     appVersion: "1.3.3", // Increment app version after fixing dark mode buttons and quick controls layout
                     language: currentLanguage,
                     darkMode: localStorage.getItem('darkMode'),
                     showArchivedUsers: showArchivedUsers // Include archived state in export
                 };

                downloadBlob(new Blob([JSON.stringify(exportObj,null,2)],{type:'application/json'}),`attendance_data_${new Date().toISOString().slice(0,10)}.json`);
                alert(translate('alertDataExported'));

                // Hide data management menu after export
                const menu = document.getElementById('dataManagementButtons');
                if(menu) menu.style.display = 'none';
                 console.log("Data exported successfully."); // Debugging

            } catch(e){
                alert(translate('alertExportFailed',{error:e.message}));
                console.error("Export failed:", e); // Debugging
            }
        }

        function handleFileUpload(event) {
             console.log("handleFileUpload called"); // Debugging
            const file = event.target.files[0];
            if(!file){
                console.log("No file selected."); // Debugging
                alert(translate('alertNoFileSelected'));
                return;
            }

            if(file.type !== 'application/json' && !file.name.toLowerCase().endsWith('.json')){
                console.log("Invalid file type selected:", file.type, file.name); // Debugging
                alert(translate('alertSelectJsonFile'));
                event.target.value = ''; // Clear the file input
                return;
            }

            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const parsedData = JSON.parse(e.target.result);
                    // Basic validation of the imported structure
                    if(!parsedData || typeof parsedData !== 'object' || !parsedData.attendanceData || typeof parsedData.attendanceData !== 'object') {
                        throw new Error(translate('alertInvalidImportFormat'));
                    }

                    // Optional: Migrate imported data structure if needed (e.g., remove location fields, add new fields)
                    const importedAttendanceData = parsedData.attendanceData;
                    let importMigrationNeeded = false;
                     for(const userName in importedAttendanceData){
                         if(importedAttendanceData[userName] && typeof importedAttendanceData[userName] === 'object') {
                             // Migrate/add new fields like overtimeRate
                             if(importedAttendanceData[userName].overtimeRate === undefined || typeof importedAttendanceData[userName].overtimeRate !== 'number' || importedAttendanceData[userName].overtimeRate <= 0) {
                                  importedAttendanceData[userName].overtimeRate = 8; importMigrationNeeded = true;
                             }

                             if (importedAttendanceData[userName].months && typeof importedAttendanceData[userName].months === 'object') {
                                 for (const monthKey in importedAttendanceData[userName].months) {
                                     if (importedAttendanceData[userName].months[monthKey] && typeof importedAttendanceData[userName].months[monthKey] === 'object') {
                                         if (Array.isArray(importedAttendanceData[userName].months[monthKey].days)) {
                                              importedAttendanceData[userName].months[monthKey].days.forEach(d => {
                                                   if (d && typeof d === 'object' && d.location !== undefined) {
                                                        delete d.location; importMigrationNeeded = true;
                                                   }
                                              });
                                         }
                                     }
                                 }
                             }
                              if (importedAttendanceData[userName].isActive === undefined) { importedAttendanceData[userName].isActive = true; importMigrationNeeded = true; } // Ensure isActive exists
                         }
                     }
                     if(importMigrationNeeded) console.log("Migration performed on imported data."); // Debugging

                    importDataBuffer = importedAttendanceData;
                    showImportPreview(importDataBuffer);
                    console.log("File read and parsed successfully."); // Debugging

                } catch(err) {
                    alert(translate('alertImportProcessingError',{error: err.message}));
                    console.error("Error processing import file:", err); // Debugging
                } finally {
                    event.target.value = ''; // Clear the file input regardless of success/failure
                }
            };
            reader.onerror = () => {
                alert(translate('alertFileReadError'));
                console.error("Error reading file."); // Debugging
                event.target.value = ''; // Clear the file input
            };
            reader.readAsText(file);
        }

        function showImportPreview(importData) {
             console.log("showImportPreview called"); // Debugging
             const modal = document.getElementById('importPreviewModal');
             const content = document.getElementById('importPreviewContent');
             const footer = modal.querySelector('.modal-footer');

             const count = importData && typeof importData === 'object' ? Object.keys(importData).length : 0;

            if (count === 0) {
                content.innerHTML = `<p>${translate('alertNoImportData')}</p>`;
                footer.style.display = 'none'; // Hide footer buttons
                console.log("No import data, hiding footer."); // Debugging
            } else {
                footer.style.display = 'flex'; // Show footer buttons
                let html = `<div class="preview-section">
                                <div class="preview-header">${translate('importPreviewTitle')}:</div>
                                <p>${translate('importContainsUsers', { count })}</p>
                            </div>
                            <div class="user-preview">`;

                // Show a preview of up to 5 user names
                const userNames = Object.keys(importData).slice(0, 5);
                userNames.forEach(name => {
                    const u = importData[name];
                    // Add checks for null/undefined user object
                    const statusText = (u && u.isActive === false) ? ` (${translate('archiveUser')})` : ''; // Use archiveUser key for clarity
                    const rate = (u && u.rate !== undefined) ? u.rate : 0;
                    const otRate = (u && u.overtimeRate !== undefined) ? u.overtimeRate : 8; // Include overtime rate in preview
                    const monthCount = (u && u.months) ? Object.keys(u.months).length : 0;
                    html += `<p><strong>${name}</strong>${statusText} - ${translate('rateLabel')} ${rate}, ${translate('overtimeRateLabel')} ${otRate}, Months: ${monthCount}</p>`; // Updated preview text
                });

                if(count > 5) {
                    html += `<p>${translate('andMoreUsers',{count: count - 5})}</p>`;
                }

                html += `</div>
                        <div class="preview-section">
                            <div class="preview-header">${translate('currentData')}</div>
                            <p>${translate('youHaveUsers',{count:Object.keys(data||{}).length})}</p>
                        </div>
                        <div class="import-option">
                            <p><strong>${translate('importChooseOption')}</strong></p>
                            <ul>
                                <li>${translate('importOptionMerge')}</li>
                                <li>${translate('importOptionReplace')}</li>
                            </ul>
                        </div>`;
                content.innerHTML = html;
                 console.log("Import preview rendered."); // Debugging
            }

            modal.style.display='block';
            applyTranslationsToUI();
            // Hide the data management menu when modal is open
            const menu = document.getElementById('dataManagementButtons');
            if(menu) menu.style.display = 'none';
        }

        function confirmImport(mode) {
             console.log("confirmImport called with mode:", mode); // Debugging
            if(!importDataBuffer){
                alert(translate('alertNoImportData'));
                console.warn("confirmImport called but no importDataBuffer."); // Debugging
                closeImportModal();
                return;
            }

            try {
                if(mode === 'replace'){
                    // Deep copy the imported data
                    data = JSON.parse(JSON.stringify(importDataBuffer));
                    localStorage.removeItem('lastSelectedUser'); // Clear last user as it might not exist in new data
                     console.log("Import mode: replace. Data replaced."); // Debugging

                } else if(mode === 'merge'){
                    console.log("import mode: merge. merging data..."); // debugging
                    for(const name in importDataBuffer){
                        const importedUser = importDataBuffer[name];
                        if (importedUser && typeof importedUser === 'object') { // Check imported user is valid
                            if (data[name]) { // User exists in current data - merge properties
                                console.log("Merging existing user:", name); // Debugging
                                data[name].rate = importedUser.rate ?? data[name].rate; // Use imported rate if exists, otherwise keep current
                                 // Merge overtimeRate, defaulting if missing/invalid in imported data
                                data[name].overtimeRate = (importedUser.overtimeRate !== undefined && typeof importedUser.overtimeRate === 'number' && importedUser.overtimeRate > 0)
                                                          ? importedUser.overtimeRate
                                                          : (data[name].overtimeRate ?? 8); // Use imported, or current, or default 8
                                data[name].isActive = importedUser.isActive ?? data[name].isActive; // Merge isActive
                                data[name].months = data[name].months || {}; // Ensure months object exists

                                if (importedUser.months && typeof importedUser.months === 'object') { // Check imported months
                                    for(const mKey in importedUser.months){
                                        const importedMonthData = importedUser.months[mKey];
                                        if (importedMonthData && typeof importedMonthData === 'object') { // Check imported month data
                                            // For months, replace the entire month's data for that user
                                            data[name].months[mKey] = JSON.parse(JSON.stringify(importedMonthData));
                                             console.log(`Merged month data for user ${name}, month ${mKey}`); // Debugging

                                            // Ensure structure of the merged month data
                                            if(typeof data[name].months[mKey].carriedOverBalance !== 'number') data[name].months[mKey].carriedOverBalance = 0;
                                            if(!Array.isArray(data[name].months[mKey].previousBalancePayments)) data[name].months[mKey].previousBalancePayments = [];
                                            if(!Array.isArray(data[name].months[mKey].days)) data[name].months[mKey].days = [];

                                            // Clean up location field in merged day data
                                            if (data[name].months[mKey].days) {
                                                 data[name].months[mKey].days.forEach(d => {
                                                      if (d && typeof d === 'object' && d.location !== undefined) delete d.location;
                                                 });
                                            }
                                        } else {
                                             console.warn(`Skipping invalid imported month data for user ${name}, month ${mKey}`); // Debugging
                                        }
                                    }
                                }
                            } else { // User does not exist in current data - add the user
                                console.log("Adding new user from import:", name); // Debugging
                                data[name] = JSON.parse(JSON.stringify(importedUser)); // Deep copy the new user data
                                // Ensure structure of the newly added user data
                                if (data[name].isActive === undefined) data[name].isActive = true;
                                if(data[name].overtimeRate === undefined || typeof data[name].overtimeRate !== 'number' || data[name].overtimeRate <= 0) data[name].overtimeRate = 8; // Add default if missing
                                data[name].months = data[name].months || {};
                                if (data[name].months) {
                                     for (const mKey in data[name].months) {
                                          if (data[name].months[mKey] && typeof data[name].months[mKey] === 'object') {
                                              if (typeof data[name].months[mKey].carriedOverBalance !== 'number') data[name].months[mKey].carriedOverBalance = 0;
                                              if (!Array.isArray(data[name].months[mKey].previousBalancePayments)) data[name].months[mKey].previousBalancePayments = [];
                                              if (!Array.isArray(data[name].months[mKey].days)) data[name].months[mKey].days = [];
                                                // Clean up location field in new user's day data
                                                if (data[name].months[mKey].days) {
                                                     data[name].months[mKey].days.forEach(d => {
                                                          if (d && typeof d === 'object' && d.location !== undefined) delete d.location;
                                                     });
                                                }
                                          }
                                     }
                                }
                            }
                        } else {
                             console.warn("Skipping invalid imported user data for user:", name, importedUser); // Debugging
                        }
                    }
                    console.log("Merge complete."); // Debugging
                }

                saveData();
                loadData(); // Reload data to update UI based on merged/replaced data
                closeImportModal();
                alert(translate('alertDataImported',{mode: mode==='replace' ? translate('replaceAllData') : translate('mergeData')}));
                console.log(`Data import successful (mode: ${mode}).`); // Debugging

            } catch(e){
                alert(translate('alertImportFailed',{error: e.message}));
                console.error("Data import failed:", e); // Debugging
                closeImportModal();
            } finally {
                importDataBuffer = null; // Clear the buffer
            }
        }

        function closeImportModal() {
             console.log("closeImportModal called"); // Debugging
             document.getElementById('importPreviewModal').style.display = 'none';
             importDataBuffer = null; // Clear buffer if modal is closed without confirming
        }

        // Initialize app on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded. Loading data..."); // Debugging
            loadData();
            // Initial render and translation application are handled within loadData and its subsequent calls (selectUser/fullRender)
        });

        // Optional: Auto-save every few minutes
        // setInterval(saveData, 300000); // Save every 5 minutes (5 * 60 * 1000)

    </script>

</body>
</html>
